import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, Q as assign, R as IconBase, v as validate_slots, T as exclude_internal_props, k as create_component, l as claim_component, m as mount_component, U as get_spread_update, V as get_spread_object, t as transition_in, p as transition_out, q as destroy_component, W as svg_element, c as claim_element, a as children, b as detach_dev, f as attr_dev, h as add_location, j as insert_dev, e as element, E as empty, F as group_outros, G as check_outros, X as readable, Y as create_slot, Z as createEventDispatcher, _ as beforeUpdate, N as listen_dev, n as noop, A as set_style, y as space, z as claim_space, $ as toggle_class, B as append_dev, a0 as is_function, a1 as update_slot, x as validate_each_argument, a2 as validate_each_keys, o as onMount, a3 as update_keyed_each, a4 as binding_callbacks, a5 as outro_and_destroy_block, a6 as bind, a7 as validate_store, a8 as component_subscribe, H as text, I as claim_text, a9 as add_flush_callback, aa as set_data_dev, L as fade, C as destroy_each, O as query_selector_all, J as add_render_callback, K as create_bidirectional_transition } from './client.3d20db51.js';
import { F as FaArrowAltCircleDown } from './FaArrowAltCircleDown.5ebd08d9.js';

/* node_modules\svelte-icons\io\IoIosCode.svelte generated by Svelte v3.29.3 */
const file = "node_modules\\svelte-icons\\io\\IoIosCode.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M332 142.7c-1.2-1.1-2.7-1.7-4.1-1.7s-3 .6-4.1 1.7L310 155.9c-1.2 1.1-1.9 2.7-1.9 4.3 0 1.6.7 3.2 1.9 4.3l95.8 91.5-95.8 91.5c-1.2 1.1-1.9 2.7-1.9 4.3 0 1.6.7 3.2 1.9 4.3l13.8 13.2c1.2 1.1 2.6 1.7 4.1 1.7 1.5 0 3-.6 4.1-1.7l114.2-109c1.2-1.1 1.9-2.7 1.9-4.3 0-1.6-.7-3.2-1.9-4.3L332 142.7zM204 160.2c0-1.6-.7-3.2-1.9-4.3l-13.8-13.2c-1.2-1.1-2.7-1.7-4.1-1.7s-3 .6-4.1 1.7l-114.2 109c-1.2 1.1-1.9 2.7-1.9 4.3 0 1.6.7 3.2 1.9 4.3l114.2 109c1.2 1.1 2.7 1.7 4.1 1.7 1.5 0 3-.6 4.1-1.7l13.8-13.2c1.2-1.1 1.9-2.7 1.9-4.3 0-1.6-.7-3.2-1.9-4.3L106.3 256l95.8-91.5c1.2-1.1 1.9-2.7 1.9-4.3z");
			add_location(path, file, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("IoIosCode", slots, []);

	$$self.$$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class IoIosCode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IoIosCode",
			options,
			id: create_fragment.name
		});
	}
}

/* src\components\Icon.svelte generated by Svelte v3.29.3 */
const file$1 = "src\\components\\Icon.svelte";

// (18:0) {#if iconName === 'code'}
function create_if_block(ctx) {
	let div;
	let ioioscode;
	let current;
	ioioscode = new IoIosCode({ props: { class: "icon" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(ioioscode.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(ioioscode.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-fpll7f");
			add_location(div, file$1, 17, 26, 305);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(ioioscode, div, null);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(ioioscode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(ioioscode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(ioioscode);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(18:0) {#if iconName === 'code'}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*iconName*/ ctx[0] === "code" && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*iconName*/ ctx[0] === "code") {
				if (if_block) {
					if (dirty & /*iconName*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Icon", slots, []);
	let { iconName } = $$props;
	const writable_props = ["iconName"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Icon> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("iconName" in $$props) $$invalidate(0, iconName = $$props.iconName);
	};

	$$self.$capture_state = () => ({ iconName, IoIosCode });

	$$self.$inject_state = $$props => {
		if ("iconName" in $$props) $$invalidate(0, iconName = $$props.iconName);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [iconName];
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { iconName: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*iconName*/ ctx[0] === undefined && !("iconName" in props)) {
			console.warn("<Icon> was created without expected prop 'iconName'");
		}
	}

	get iconName() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconName(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const personalLetter = "Jag heter William och är 26 år gammal från Stockholm. Med ett tidigt intresse för matematik och havet studerade jag på Marina Läroverket i Stocksund, inriktning natur och marinbiologi. Efter gymnasiet jobbade jag ett år, på kryssningsfartyg i Medelhavet och som brevbärare, och sen reste jag i Sydostasien. Jag hade sedan gymnasiet haft siktet på Kungliga Tekniska Högskolan. Därför sökte jag till linjen Civilingenjör och Lärare eftersom jag ville kombinera mitt tekniska intresse med min sociala kompetens. Under andra året på utbildningen valde jag inriktningen informations- och kommunikationsteknik. Utbildningen ger mig möjlighet att jobba som gymnasielärare i matematik, teknik och programmering men även som civilingenjör inom programmering och IT. Under utbildningen fick jag goda kunskaper inom programmering, framförallt inom frontend-utveckling. var att skriva lösningar i Latex och göra grafer i Javascript med biblioteket JSXGraph. Efter mitt examensarbete inom digitalt lärande på Mathleaks fick jag erbjudande om heltidsanställning. Med två kurser kvar på utbildning valde jag att ta jobbet då jag såg det som en stor möjlighet att utvecklas på ett startup. Under mina första två år på Mathleaks har jag drivit fler projekt, blandad annat produktutvecklingen inför USA lanseringen. Det har gjort mig flytande i såväl formell engelska som Latex. Jag har fått jobba med projektledning med Trello och interna system med Javascript, HTML, CSS och AngularJS. Senaste projektet var att sätta upp en Node-server för rendrering av Javascript till statiska SVG-filer. IT- teamet jobbar remote vilket har gjort att vikten på Git och Bitbucket har varit stor. Jag har lärt mig att granska andras kod samtidigt som jag själv kunnat utvecklas genom feedback. Jag känner nu att det är dags att ta steget till att bli en renodlad programmerare. Jag har fått upp ett stort intresse för programmering och har som hobbyprojekt skapat hemsidan https://poddsok.nu. Det är en hemsida där användare kan hitta ord och meningar som nämns i podcasts. Den är byggd med AngularJS, Firebase som backend och med API:er från Spotify och Itunes. På den här banan vill jag fortsätta kombinera min touch för design med mitt logiska och tekniska tänkande för att lär mig de senaste ramverken och biblioteket inom frontend Jag söker mig därför till er då jag tror jag kommer kunna utvecklas enormt men även bidra mycket med min pedagogiska bakgrund. Den är inte bara användbar i skolan utan i alla delar av samhället. Något jag märkt framförallt under mina år på Mathleaks är att det är lättare för mig att förstå en icke programmerar och översätta hens tankar till kod. Som konsult tror jag det är bra att vara mångsidig och ha lätt för att sammarbeta. Jag tycker den sociala delen och kollegorna är en viktig del av yrket. Efter att ha jobbat på engelska både skriftligt och muntligt är jag väldigt bekväm med språket och känner att det även utvecklat mitt sätt att skriva kod. Jag har blivit mer strukturerad och bättre på att skriva lättläslig kod. Med detta kommer att jag har lättare att ta till mig och lära mig nya områden inom programmering självmant. Jag tror jag kommer kunna bidra med nya och kreativa idéer samt leverans på utsatta deadlines. Under det senaste året har jag verkligen förstått innebörden av hårt arbete och var man kan nå om man bara har viljan och drivet. Jag har implementerat både sökalgoritmer, formulär och layout för data från t.ex. API- anropp. Det tror jag är fördelaktiga kunskaper för att passa i era team och hjälpa företag att digitalisera sin kommunikation och kundhantering. Om ni har några frågor eller vill veta något mer är det bara att höra av er!";

let getPersonalLetter = readable( personalLetter );

const debounce = (fn, ms = 0) => {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), ms);
  };
};

function getRowsCount(items, cols) {
  return Math.max(
    ...items.map((val) => {
      const item = val[cols];
      return item?.y + item?.h;
    }),
    1,
  );
}

const getColumn = (containerWidth, columns) => {
  try {
    let [_, cols] = columns
      .slice()
      .reverse()
      .find((value) => {
        const [width, cols] = value;
        return containerWidth <= width;
      });
    return cols;
  } catch {
    return columns[columns.length - 1];
  }
};

function getContainerHeight(items, yPerPx, cols) {
  return getRowsCount(items, cols) * yPerPx;
}

const makeMatrix = (rows, cols) => Array.from(Array(rows), () => new Array(cols)); // make 2d array

function findCloseBlocks(items, matrix, curObject) {
  const { h, x, y } = curObject;

  const w = Math.min(matrix[0].length, curObject.w);
  const tempR = matrix.slice(y, y + h);

  let result = [];
  for (var i = 0; i < tempR.length; i++) {
    let tempA = tempR[i].slice(x, x + w);
    result = [...result, ...tempA.map((val) => val.id && val.id !== curObject.id && val.id).filter(Boolean)];
  }

  return [...new Set(result)];
}

function makeMatrixFromItemsIgnore(items, ignoreList, _row, _col) {
  let matrix = makeMatrix(_row, _col);
  for (var i = 0; i < items.length; i++) {
    const value = items[i][_col];
    const id = items[i].id;
    const { x, y, h } = value;
    const w = Math.min(_col, value.w);

    if (ignoreList.indexOf(id) === -1) {
      for (var j = y; j < y + h; j++) {
        const row = matrix[j];
        if (row) {
          for (var k = x; k < x + w; k++) {
            row[k] = { ...value, id };
          }
        }
      }
    }
  }
  return matrix;
}

function findItemsById(closeBlocks, items) {
  return items.filter((value) => closeBlocks.indexOf(value.id) !== -1);
}

function getItemById(id, items) {
  return items.find((value) => value.id === id);
}

function findFreeSpaceForItem(matrix, item, items = []) {
  const cols = matrix[0].length;
  const w = Math.min(cols, item.w);
  let xNtime = cols - w;

  for (var i = 0; i < matrix.length; i++) {
    const row = matrix[i];
    for (var j = 0; j < xNtime + 1; j++) {
      const sliceA = row.slice(j, j + w);
      const empty = sliceA.every((val) => val === undefined);
      if (empty) {
        const isEmpty = matrix.slice(i, i + item.h).every((a) => a.slice(j, j + w).every((n) => n === undefined));

        if (isEmpty) {
          return { y: i, x: j };
        }
      }
    }
  }

  return {
    y: getRowsCount(items, cols),
    x: 0,
  };
}

const getItem = (item, col) => {
  return { ...item[col], id: item.id };
};

const updateItem = (elements, active, position, col) => {
  return elements.map((value) => {
    if (value.id === active.id) {
      return { ...value, [col]: { ...value[col], ...position } };
    }
    return value;
  });
};

function moveItem(active, items, cols, original) {
  // Get current item from the breakpoint
  const item = getItem(active, cols);
  // Create matrix from the items expect the active
  let matrix = makeMatrixFromItemsIgnore(items, [item.id], getRowsCount(items, cols), cols);
  // Getting the ids of items under active Array<String>
  const closeBlocks = findCloseBlocks(items, matrix, item);
  // Getting the objects of items under active Array<Object>
  let closeObj = findItemsById(closeBlocks, items);
  // Getting whenever of these items is fixed
  const fixed = closeObj.find((value) => value[cols].fixed);

  // If found fixed, reset the active to its original position
  if (fixed) return items;

  // Update items
  items = updateItem(items, active, item, cols);

  // Create matrix of items expect close elements
  matrix = makeMatrixFromItemsIgnore(items, closeBlocks, getRowsCount(items, cols), cols);

  // Create temp vars
  let tempItems = items;
  let tempCloseBlocks = closeBlocks;

  // Exclude resolved elements ids in array
  let exclude = [];

  // Iterate over close elements under active item
  closeObj.forEach((item) => {
    // Find position for element
    let position = findFreeSpaceForItem(matrix, item[cols], tempItems);
    // Exclude item
    exclude.push(item.id);

    // If position is found
    if (position) {
      // Assign the position to the element in the column
      tempItems = updateItem(tempItems, item, position, cols);

      // Recreate ids of elements
      let getIgnoreItems = tempCloseBlocks.filter((value) => exclude.indexOf(value) === -1);

      // Update matrix for next iteration
      matrix = makeMatrixFromItemsIgnore(tempItems, getIgnoreItems, getRowsCount(tempItems, cols), cols);
    }
  });

  // Return result
  return tempItems;
}

/* node_modules\svelte-grid\src\MoveResize\index.svelte generated by Svelte v3.29.3 */
const file$2 = "node_modules\\svelte-grid\\src\\MoveResize\\index.svelte";
const get_default_slot_changes = dirty => ({});
const get_default_slot_context = ctx => ({ pointerdown: /*pointerdown*/ ctx[14] });

// (82:2) {#if resizable}
function create_if_block_1(ctx) {
	let div;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svlt-grid-resizer svelte-gu74pr");
			add_location(div, file$2, 82, 4, 1999);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (!mounted) {
				dispose = listen_dev(div, "pointerdown", /*resizePointerDown*/ ctx[15], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(82:2) {#if resizable}",
		ctx
	});

	return block;
}

// (87:0) {#if active}
function create_if_block$1(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			children(div).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svlt-grid-shadow transition shadow-active svelte-gu74pr");
			set_style(div, "width", /*shadow*/ ctx[11].w * /*xPerPx*/ ctx[6] - /*gapX*/ ctx[8] * 2 + "px");
			set_style(div, "height", /*shadow*/ ctx[11].h * /*yPerPx*/ ctx[7] - /*gapY*/ ctx[9] * 2 + "px");
			set_style(div, "transform", "translate(" + (/*shadow*/ ctx[11].x * /*xPerPx*/ ctx[6] + /*gapX*/ ctx[8]) + "px, " + (/*shadow*/ ctx[11].y * /*yPerPx*/ ctx[7] + /*gapY*/ ctx[9]) + "px)");
			add_location(div, file$2, 87, 2, 2099);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*shadow, xPerPx, gapX*/ 2368) {
				set_style(div, "width", /*shadow*/ ctx[11].w * /*xPerPx*/ ctx[6] - /*gapX*/ ctx[8] * 2 + "px");
			}

			if (dirty[0] & /*shadow, yPerPx, gapY*/ 2688) {
				set_style(div, "height", /*shadow*/ ctx[11].h * /*yPerPx*/ ctx[7] - /*gapY*/ ctx[9] * 2 + "px");
			}

			if (dirty[0] & /*shadow, xPerPx, gapX, yPerPx, gapY*/ 3008) {
				set_style(div, "transform", "translate(" + (/*shadow*/ ctx[11].x * /*xPerPx*/ ctx[6] + /*gapX*/ ctx[8]) + "px, " + (/*shadow*/ ctx[11].y * /*yPerPx*/ ctx[7] + /*gapY*/ ctx[9]) + "px)");
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(87:0) {#if active}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div;
	let t0;
	let t1;
	let if_block1_anchor;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[22].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], get_default_slot_context);
	let if_block0 = /*resizable*/ ctx[4] && create_if_block_1(ctx);
	let if_block1 = /*active*/ ctx[12] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			div_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svlt-grid-item svelte-gu74pr");

			set_style(div, "width", (/*active*/ ctx[12]
			? /*cloneBound*/ ctx[13].width
			: /*width*/ ctx[0]) + "px");

			set_style(div, "height", (/*active*/ ctx[12]
			? /*cloneBound*/ ctx[13].height
			: /*height*/ ctx[1]) + "px");

			set_style(div, "transform", "translate(" + (/*active*/ ctx[12]
			? /*cloneBound*/ ctx[13].left
			: /*left*/ ctx[2]) + "px, " + (/*active*/ ctx[12]
			? /*cloneBound*/ ctx[13].top
			: /*top*/ ctx[3]) + "px)");

			toggle_class(div, "transition", !/*active*/ ctx[12]);
			toggle_class(div, "active", /*active*/ ctx[12]);
			toggle_class(div, "no-user", /*active*/ ctx[12]);
			add_location(div, file$2, 73, 0, 1588);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			insert_dev(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(
					div,
					"pointerdown",
					function () {
						if (is_function((/*item*/ ctx[10]?.custom)
						? null
						: /*draggable*/ ctx[5] && /*pointerdown*/ ctx[14])) ((/*item*/ ctx[10]?.custom)
						? null
						: /*draggable*/ ctx[5] && /*pointerdown*/ ctx[14]).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 2097152) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[21], dirty, get_default_slot_changes, get_default_slot_context);
				}
			}

			if (/*resizable*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(div, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!current || dirty[0] & /*active, cloneBound, width*/ 12289) {
				set_style(div, "width", (/*active*/ ctx[12]
				? /*cloneBound*/ ctx[13].width
				: /*width*/ ctx[0]) + "px");
			}

			if (!current || dirty[0] & /*active, cloneBound, height*/ 12290) {
				set_style(div, "height", (/*active*/ ctx[12]
				? /*cloneBound*/ ctx[13].height
				: /*height*/ ctx[1]) + "px");
			}

			if (!current || dirty[0] & /*active, cloneBound, left, top*/ 12300) {
				set_style(div, "transform", "translate(" + (/*active*/ ctx[12]
				? /*cloneBound*/ ctx[13].left
				: /*left*/ ctx[2]) + "px, " + (/*active*/ ctx[12]
				? /*cloneBound*/ ctx[13].top
				: /*top*/ ctx[3]) + "px)");
			}

			if (dirty[0] & /*active*/ 4096) {
				toggle_class(div, "transition", !/*active*/ ctx[12]);
			}

			if (dirty[0] & /*active*/ 4096) {
				toggle_class(div, "active", /*active*/ ctx[12]);
			}

			if (dirty[0] & /*active*/ 4096) {
				toggle_class(div, "no-user", /*active*/ ctx[12]);
			}

			if (/*active*/ ctx[12]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (detaching) detach_dev(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("MoveResize", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { width } = $$props;
	let { height } = $$props;
	let { left } = $$props;
	let { top } = $$props;
	let { resizable } = $$props;
	let { draggable } = $$props;
	let { id } = $$props;
	let { xPerPx } = $$props;
	let { yPerPx } = $$props;
	let { gapX } = $$props;
	let { gapY } = $$props;
	let { item } = $$props;
	let { dynamic } = $$props;
	let { max } = $$props;
	let { min } = $$props;
	let { cols } = $$props;

	let shadow = {
		x: item?.x,
		y: item?.y,
		w: item?.w,
		h: item?.h
	};

	let active = false;
	let debounce = false;
	let initX, initY;
	let xyRef = { x: left, y: top };
	let newXY = { x: 0, y: 0 };
	let cloneBound = { width, height, top, left };

	const inActivate = () => {
		$$invalidate(12, active = false);
		dispatch("pointerup", { id });
	};

	let repaint = (listen = true) => {
		const onUpdate = !listen ? false : inActivate;
		dispatch("repaint", { id, shadow, onUpdate });
	};

	beforeUpdate(() => {
		if (xPerPx && !debounce) {
			xyRef = { x: left, y: top };

			$$invalidate(11, shadow = {
				x: item?.x,
				y: item?.y,
				w: item?.w,
				h: item?.h
			});

			debounce = true;
		}
	});

	const pointerdown = ({ pageX, pageY, clientX, clientY }) => {
		initX = pageX;
		initY = pageY;
		$$invalidate(13, cloneBound = { width, height, top, left });
		debounce = false;
		$$invalidate(12, active = true);
		window.addEventListener("pointermove", pointermove);
		window.addEventListener("pointerup", pointerup);
		window.addEventListener("pointercancel", pointerup);
	};

	const pointermove = ({ pageX, pageY, clientX, clientY }) => {
		newXY = { x: initX - pageX, y: initY - pageY };
		$$invalidate(13, cloneBound.left = xyRef.x - newXY.x, cloneBound);
		$$invalidate(13, cloneBound.top = xyRef.y - newXY.y, cloneBound);
		let gridX = Math.round(cloneBound.left / xPerPx);
		let gridY = Math.round(cloneBound.top / yPerPx);
		$$invalidate(11, shadow.x = Math.max(Math.min(gridX, cols - shadow.w), 0), shadow);
		$$invalidate(11, shadow.y = Math.max(gridY, 0), shadow);
		if (dynamic) repaint(false);
	};

	const pointerup = e => {
		xyRef.x -= newXY.x;
		xyRef.y -= newXY.y;
		window.removeEventListener("pointerdown", pointerdown);
		window.removeEventListener("pointermove", pointermove);
		window.removeEventListener("pointerup", pointerup);
		window.removeEventListener("pointercancel", pointerup);
		repaint();
	};

	// Resize
	let resizeInitX, resizeInitY;

	let initialWidth = 0;
	let initialHeight = 0;

	const resizePointerDown = e => {
		e.stopPropagation();
		const { pageX, pageY } = e;
		resizeInitX = pageX;
		resizeInitY = pageY;
		initialWidth = width;
		initialHeight = height;
		$$invalidate(13, cloneBound = { width, height, top, left });
		$$invalidate(12, active = true);
		const { x, y, w, h } = item;
		$$invalidate(11, shadow = { x, y, w, h });
		window.addEventListener("pointermove", resizePointerMove);
		window.addEventListener("pointerup", resizePointerUp);
		window.addEventListener("pointercancel", resizePointerUp);
	};

	const resizePointerMove = ({ pageX, pageY }) => {
		$$invalidate(13, cloneBound.width = initialWidth + pageX - resizeInitX, cloneBound);
		$$invalidate(13, cloneBound.height = initialHeight + pageY - resizeInitY, cloneBound);
		$$invalidate(11, shadow.w = Math.round(cloneBound.width / xPerPx), shadow);
		$$invalidate(11, shadow.h = Math.round(cloneBound.height / yPerPx), shadow);
		let maxWidth = Math.min(max.w, cols) || cols;
		$$invalidate(11, shadow.w = Math.max(Math.min(maxWidth, shadow.w), min.w), shadow);
		$$invalidate(11, shadow.h = Math.max(shadow.h, min.h), shadow);

		if (max.h) {
			$$invalidate(11, shadow.h = Math.min(max.h, shadow.h), shadow);
		}
	};

	const resizePointerUp = e => {
		e.stopPropagation();
		repaint();
		window.removeEventListener("pointermove", resizePointerMove);
		window.removeEventListener("pointerup", resizePointerUp);
		window.removeEventListener("pointercancel", resizePointerUp);
	};

	const writable_props = [
		"width",
		"height",
		"left",
		"top",
		"resizable",
		"draggable",
		"id",
		"xPerPx",
		"yPerPx",
		"gapX",
		"gapY",
		"item",
		"dynamic",
		"max",
		"min",
		"cols"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MoveResize> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("width" in $$props) $$invalidate(0, width = $$props.width);
		if ("height" in $$props) $$invalidate(1, height = $$props.height);
		if ("left" in $$props) $$invalidate(2, left = $$props.left);
		if ("top" in $$props) $$invalidate(3, top = $$props.top);
		if ("resizable" in $$props) $$invalidate(4, resizable = $$props.resizable);
		if ("draggable" in $$props) $$invalidate(5, draggable = $$props.draggable);
		if ("id" in $$props) $$invalidate(16, id = $$props.id);
		if ("xPerPx" in $$props) $$invalidate(6, xPerPx = $$props.xPerPx);
		if ("yPerPx" in $$props) $$invalidate(7, yPerPx = $$props.yPerPx);
		if ("gapX" in $$props) $$invalidate(8, gapX = $$props.gapX);
		if ("gapY" in $$props) $$invalidate(9, gapY = $$props.gapY);
		if ("item" in $$props) $$invalidate(10, item = $$props.item);
		if ("dynamic" in $$props) $$invalidate(17, dynamic = $$props.dynamic);
		if ("max" in $$props) $$invalidate(18, max = $$props.max);
		if ("min" in $$props) $$invalidate(19, min = $$props.min);
		if ("cols" in $$props) $$invalidate(20, cols = $$props.cols);
		if ("$$scope" in $$props) $$invalidate(21, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		beforeUpdate,
		dispatch,
		width,
		height,
		left,
		top,
		resizable,
		draggable,
		id,
		xPerPx,
		yPerPx,
		gapX,
		gapY,
		item,
		dynamic,
		max,
		min,
		cols,
		shadow,
		active,
		debounce,
		initX,
		initY,
		xyRef,
		newXY,
		cloneBound,
		inActivate,
		repaint,
		pointerdown,
		pointermove,
		pointerup,
		resizeInitX,
		resizeInitY,
		initialWidth,
		initialHeight,
		resizePointerDown,
		resizePointerMove,
		resizePointerUp
	});

	$$self.$inject_state = $$props => {
		if ("width" in $$props) $$invalidate(0, width = $$props.width);
		if ("height" in $$props) $$invalidate(1, height = $$props.height);
		if ("left" in $$props) $$invalidate(2, left = $$props.left);
		if ("top" in $$props) $$invalidate(3, top = $$props.top);
		if ("resizable" in $$props) $$invalidate(4, resizable = $$props.resizable);
		if ("draggable" in $$props) $$invalidate(5, draggable = $$props.draggable);
		if ("id" in $$props) $$invalidate(16, id = $$props.id);
		if ("xPerPx" in $$props) $$invalidate(6, xPerPx = $$props.xPerPx);
		if ("yPerPx" in $$props) $$invalidate(7, yPerPx = $$props.yPerPx);
		if ("gapX" in $$props) $$invalidate(8, gapX = $$props.gapX);
		if ("gapY" in $$props) $$invalidate(9, gapY = $$props.gapY);
		if ("item" in $$props) $$invalidate(10, item = $$props.item);
		if ("dynamic" in $$props) $$invalidate(17, dynamic = $$props.dynamic);
		if ("max" in $$props) $$invalidate(18, max = $$props.max);
		if ("min" in $$props) $$invalidate(19, min = $$props.min);
		if ("cols" in $$props) $$invalidate(20, cols = $$props.cols);
		if ("shadow" in $$props) $$invalidate(11, shadow = $$props.shadow);
		if ("active" in $$props) $$invalidate(12, active = $$props.active);
		if ("debounce" in $$props) debounce = $$props.debounce;
		if ("initX" in $$props) initX = $$props.initX;
		if ("initY" in $$props) initY = $$props.initY;
		if ("xyRef" in $$props) xyRef = $$props.xyRef;
		if ("newXY" in $$props) newXY = $$props.newXY;
		if ("cloneBound" in $$props) $$invalidate(13, cloneBound = $$props.cloneBound);
		if ("repaint" in $$props) repaint = $$props.repaint;
		if ("resizeInitX" in $$props) resizeInitX = $$props.resizeInitX;
		if ("resizeInitY" in $$props) resizeInitY = $$props.resizeInitY;
		if ("initialWidth" in $$props) initialWidth = $$props.initialWidth;
		if ("initialHeight" in $$props) initialHeight = $$props.initialHeight;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		width,
		height,
		left,
		top,
		resizable,
		draggable,
		xPerPx,
		yPerPx,
		gapX,
		gapY,
		item,
		shadow,
		active,
		cloneBound,
		pointerdown,
		resizePointerDown,
		id,
		dynamic,
		max,
		min,
		cols,
		$$scope,
		slots
	];
}

class MoveResize extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$2,
			create_fragment$2,
			safe_not_equal,
			{
				width: 0,
				height: 1,
				left: 2,
				top: 3,
				resizable: 4,
				draggable: 5,
				id: 16,
				xPerPx: 6,
				yPerPx: 7,
				gapX: 8,
				gapY: 9,
				item: 10,
				dynamic: 17,
				max: 18,
				min: 19,
				cols: 20
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MoveResize",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*width*/ ctx[0] === undefined && !("width" in props)) {
			console.warn("<MoveResize> was created without expected prop 'width'");
		}

		if (/*height*/ ctx[1] === undefined && !("height" in props)) {
			console.warn("<MoveResize> was created without expected prop 'height'");
		}

		if (/*left*/ ctx[2] === undefined && !("left" in props)) {
			console.warn("<MoveResize> was created without expected prop 'left'");
		}

		if (/*top*/ ctx[3] === undefined && !("top" in props)) {
			console.warn("<MoveResize> was created without expected prop 'top'");
		}

		if (/*resizable*/ ctx[4] === undefined && !("resizable" in props)) {
			console.warn("<MoveResize> was created without expected prop 'resizable'");
		}

		if (/*draggable*/ ctx[5] === undefined && !("draggable" in props)) {
			console.warn("<MoveResize> was created without expected prop 'draggable'");
		}

		if (/*id*/ ctx[16] === undefined && !("id" in props)) {
			console.warn("<MoveResize> was created without expected prop 'id'");
		}

		if (/*xPerPx*/ ctx[6] === undefined && !("xPerPx" in props)) {
			console.warn("<MoveResize> was created without expected prop 'xPerPx'");
		}

		if (/*yPerPx*/ ctx[7] === undefined && !("yPerPx" in props)) {
			console.warn("<MoveResize> was created without expected prop 'yPerPx'");
		}

		if (/*gapX*/ ctx[8] === undefined && !("gapX" in props)) {
			console.warn("<MoveResize> was created without expected prop 'gapX'");
		}

		if (/*gapY*/ ctx[9] === undefined && !("gapY" in props)) {
			console.warn("<MoveResize> was created without expected prop 'gapY'");
		}

		if (/*item*/ ctx[10] === undefined && !("item" in props)) {
			console.warn("<MoveResize> was created without expected prop 'item'");
		}

		if (/*dynamic*/ ctx[17] === undefined && !("dynamic" in props)) {
			console.warn("<MoveResize> was created without expected prop 'dynamic'");
		}

		if (/*max*/ ctx[18] === undefined && !("max" in props)) {
			console.warn("<MoveResize> was created without expected prop 'max'");
		}

		if (/*min*/ ctx[19] === undefined && !("min" in props)) {
			console.warn("<MoveResize> was created without expected prop 'min'");
		}

		if (/*cols*/ ctx[20] === undefined && !("cols" in props)) {
			console.warn("<MoveResize> was created without expected prop 'cols'");
		}
	}

	get width() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get left() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set left(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get top() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set top(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizable() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizable(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get draggable() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set draggable(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xPerPx() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xPerPx(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get yPerPx() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set yPerPx(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get gapX() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set gapX(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get gapY() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set gapY(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get item() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set item(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dynamic() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dynamic(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get cols() {
		throw new Error("<MoveResize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set cols(value) {
		throw new Error("<MoveResize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-grid\src\index.svelte generated by Svelte v3.29.3 */
const file$3 = "node_modules\\svelte-grid\\src\\index.svelte";

const get_default_slot_changes$1 = dirty => ({
	pointerdown: dirty & /*pointerdown*/ 536870912,
	dataItem: dirty & /*items*/ 1,
	item: dirty & /*items, getComputedCols*/ 5,
	index: dirty & /*items*/ 1
});

const get_default_slot_context$1 = ctx => ({
	pointerdown: /*pointerdown*/ ctx[29],
	dataItem: /*item*/ ctx[26],
	item: /*item*/ ctx[26][/*getComputedCols*/ ctx[2]],
	index: /*i*/ ctx[28]
});

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i];
	child_ctx[28] = i;
	return child_ctx;
}

// (9:4) <MoveResize       on:repaint={handleRepaint}       on:pointerup={pointerup}       id={item.id}       index={i}       resizable={item[getComputedCols]?.resizable}       draggable={item[getComputedCols]?.draggable}       {xPerPx}       {yPerPx}       width={Math.min(getComputedCols, item[getComputedCols]?.w) * xPerPx - gapX * 2}       height={item[getComputedCols]?.h * yPerPx - gapX * 2}       top={item[getComputedCols]?.y * yPerPx + gapY}       left={item[getComputedCols]?.x * xPerPx + gapX}       item={item[getComputedCols]}       min={item[getComputedCols]?.min}       max={item[getComputedCols]?.max}       {dynamic}       cols={getComputedCols}       {gapX}       {gapY}       let:pointerdown>
function create_default_slot$1(ctx) {
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], get_default_slot_context$1);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
			t = space();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
			t = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, pointerdown, items, getComputedCols*/ 537395205) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, get_default_slot_changes$1, get_default_slot_context$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(9:4) <MoveResize       on:repaint={handleRepaint}       on:pointerup={pointerup}       id={item.id}       index={i}       resizable={item[getComputedCols]?.resizable}       draggable={item[getComputedCols]?.draggable}       {xPerPx}       {yPerPx}       width={Math.min(getComputedCols, item[getComputedCols]?.w) * xPerPx - gapX * 2}       height={item[getComputedCols]?.h * yPerPx - gapX * 2}       top={item[getComputedCols]?.y * yPerPx + gapY}       left={item[getComputedCols]?.x * xPerPx + gapX}       item={item[getComputedCols]}       min={item[getComputedCols]?.min}       max={item[getComputedCols]?.max}       {dynamic}       cols={getComputedCols}       {gapX}       {gapY}       let:pointerdown>",
		ctx
	});

	return block;
}

// (8:2) {#each items as item, i (item.id)}
function create_each_block(key_1, ctx) {
	let first;
	let moveresize;
	let current;

	moveresize = new MoveResize({
			props: {
				id: /*item*/ ctx[26].id,
				index: /*i*/ ctx[28],
				resizable: /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.resizable,
				draggable: /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.draggable,
				xPerPx: /*xPerPx*/ ctx[4],
				yPerPx: /*yPerPx*/ ctx[8],
				width: Math.min(/*getComputedCols*/ ctx[2], /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.w) * /*xPerPx*/ ctx[4] - /*gapX*/ ctx[5] * 2,
				height: /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.h * /*yPerPx*/ ctx[8] - /*gapX*/ ctx[5] * 2,
				top: /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.y * /*yPerPx*/ ctx[8] + /*gapY*/ ctx[6],
				left: /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.x * /*xPerPx*/ ctx[4] + /*gapX*/ ctx[5],
				item: /*item*/ ctx[26][/*getComputedCols*/ ctx[2]],
				min: /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.min,
				max: /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.max,
				dynamic: /*dynamic*/ ctx[1],
				cols: /*getComputedCols*/ ctx[2],
				gapX: /*gapX*/ ctx[5],
				gapY: /*gapY*/ ctx[6],
				$$slots: {
					default: [
						create_default_slot$1,
						({ pointerdown }) => ({ 29: pointerdown }),
						({ pointerdown }) => pointerdown ? 536870912 : 0
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	moveresize.$on("repaint", /*handleRepaint*/ ctx[10]);
	moveresize.$on("pointerup", /*pointerup*/ ctx[9]);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(moveresize.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			first = empty();
			claim_component(moveresize.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(moveresize, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const moveresize_changes = {};
			if (dirty & /*items*/ 1) moveresize_changes.id = /*item*/ ctx[26].id;
			if (dirty & /*items*/ 1) moveresize_changes.index = /*i*/ ctx[28];
			if (dirty & /*items, getComputedCols*/ 5) moveresize_changes.resizable = /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.resizable;
			if (dirty & /*items, getComputedCols*/ 5) moveresize_changes.draggable = /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.draggable;
			if (dirty & /*xPerPx*/ 16) moveresize_changes.xPerPx = /*xPerPx*/ ctx[4];
			if (dirty & /*getComputedCols, items, xPerPx, gapX*/ 53) moveresize_changes.width = Math.min(/*getComputedCols*/ ctx[2], /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.w) * /*xPerPx*/ ctx[4] - /*gapX*/ ctx[5] * 2;
			if (dirty & /*items, getComputedCols, gapX*/ 37) moveresize_changes.height = /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.h * /*yPerPx*/ ctx[8] - /*gapX*/ ctx[5] * 2;
			if (dirty & /*items, getComputedCols, gapY*/ 69) moveresize_changes.top = /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.y * /*yPerPx*/ ctx[8] + /*gapY*/ ctx[6];
			if (dirty & /*items, getComputedCols, xPerPx, gapX*/ 53) moveresize_changes.left = /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.x * /*xPerPx*/ ctx[4] + /*gapX*/ ctx[5];
			if (dirty & /*items, getComputedCols*/ 5) moveresize_changes.item = /*item*/ ctx[26][/*getComputedCols*/ ctx[2]];
			if (dirty & /*items, getComputedCols*/ 5) moveresize_changes.min = /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.min;
			if (dirty & /*items, getComputedCols*/ 5) moveresize_changes.max = /*item*/ ctx[26][/*getComputedCols*/ ctx[2]]?.max;
			if (dirty & /*dynamic*/ 2) moveresize_changes.dynamic = /*dynamic*/ ctx[1];
			if (dirty & /*getComputedCols*/ 4) moveresize_changes.cols = /*getComputedCols*/ ctx[2];
			if (dirty & /*gapX*/ 32) moveresize_changes.gapX = /*gapX*/ ctx[5];
			if (dirty & /*gapY*/ 64) moveresize_changes.gapY = /*gapY*/ ctx[6];

			if (dirty & /*$$scope, pointerdown, items, getComputedCols*/ 537395205) {
				moveresize_changes.$$scope = { dirty, ctx };
			}

			moveresize.$set(moveresize_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(moveresize.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(moveresize.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(moveresize, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(8:2) {#each items as item, i (item.id)}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*items*/ ctx[0];
	validate_each_argument(each_value);
	const get_key = ctx => /*item*/ ctx[26].id;
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svlt-grid-container svelte-72eorp");
			set_style(div, "height", /*containerHeight*/ ctx[7] + "px");
			add_location(div, file$3, 6, 0, 140);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			/*div_binding*/ ctx[18](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*items, getComputedCols, xPerPx, yPerPx, Math, gapX, gapY, dynamic, handleRepaint, pointerup, $$scope, pointerdown*/ 537397111) {
				const each_value = /*items*/ ctx[0];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
				check_outros();
			}

			if (!current || dirty & /*containerHeight*/ 128) {
				set_style(div, "height", /*containerHeight*/ ctx[7] + "px");
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*div_binding*/ ctx[18](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Src", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { items } = $$props;
	let { rowHeight } = $$props;
	let { cols } = $$props;
	let { gap = [10, 10] } = $$props;
	let { dynamicCols = true } = $$props;
	let { debounceUpdate = 100 } = $$props;
	let { debounceResize = 100 } = $$props;
	let { dynamic = false } = $$props;
	let getComputedCols;
	let container;
	let xPerPx = 0;
	let yPerPx = rowHeight;
	let documentWidth;
	let containerWidth;
	let prevCols;

	const pointerup = ev => {
		dispatch("pointerup", { id: ev.detail.id, cols: getComputedCols });
	};

	const onResize = debounce(
		() => {
			dispatch("resize", {
				cols: getComputedCols,
				xPerPx,
				yPerPx,
				width: containerWidth
			});
		},
		debounceResize
	);

	onMount(() => {
		const sizeObserver = new ResizeObserver(entries => {
				let width = entries[0].contentRect.width;
				if (width === containerWidth) return;
				$$invalidate(2, getComputedCols = getColumn(width, cols));
				$$invalidate(4, xPerPx = width / getComputedCols);

				if (!containerWidth) {
					dispatch("mount", {
						cols: getComputedCols,
						xPerPx,
						yPerPx, // same as rowHeight
						
					});
				} else {
					onResize();
				}

				$$invalidate(20, containerWidth = width);
			});

		sizeObserver.observe(container);
		return () => sizeObserver.disconnect();
	});

	const updateMatrix = ({ detail }) => {
		let activeItem = getItemById(detail.id, items);

		if (activeItem) {
			activeItem = {
				...activeItem,
				[getComputedCols]: {
					...activeItem[getComputedCols],
					...detail.shadow
				}
			};

			$$invalidate(0, items = moveItem(activeItem, items, getComputedCols, getItemById(detail.id, items)));
			if (detail.onUpdate) detail.onUpdate();

			dispatch("change", {
				unsafeItem: activeItem,
				id: activeItem.id,
				cols: getComputedCols
			});
		}
	};

	const handleRepaint = debounce(updateMatrix, debounceUpdate);

	const writable_props = [
		"items",
		"rowHeight",
		"cols",
		"gap",
		"dynamicCols",
		"debounceUpdate",
		"debounceResize",
		"dynamic"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Src> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(3, container);
		});
	}

	$$self.$$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
		if ("rowHeight" in $$props) $$invalidate(11, rowHeight = $$props.rowHeight);
		if ("cols" in $$props) $$invalidate(12, cols = $$props.cols);
		if ("gap" in $$props) $$invalidate(13, gap = $$props.gap);
		if ("dynamicCols" in $$props) $$invalidate(14, dynamicCols = $$props.dynamicCols);
		if ("debounceUpdate" in $$props) $$invalidate(15, debounceUpdate = $$props.debounceUpdate);
		if ("debounceResize" in $$props) $$invalidate(16, debounceResize = $$props.debounceResize);
		if ("dynamic" in $$props) $$invalidate(1, dynamic = $$props.dynamic);
		if ("$$scope" in $$props) $$invalidate(19, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContainerHeight,
		moveItem,
		getItemById,
		onMount,
		createEventDispatcher,
		debounce,
		getColumn,
		MoveResize,
		dispatch,
		items,
		rowHeight,
		cols,
		gap,
		dynamicCols,
		debounceUpdate,
		debounceResize,
		dynamic,
		getComputedCols,
		container,
		xPerPx,
		yPerPx,
		documentWidth,
		containerWidth,
		prevCols,
		pointerup,
		onResize,
		updateMatrix,
		handleRepaint,
		gapX,
		gapY,
		containerHeight
	});

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
		if ("rowHeight" in $$props) $$invalidate(11, rowHeight = $$props.rowHeight);
		if ("cols" in $$props) $$invalidate(12, cols = $$props.cols);
		if ("gap" in $$props) $$invalidate(13, gap = $$props.gap);
		if ("dynamicCols" in $$props) $$invalidate(14, dynamicCols = $$props.dynamicCols);
		if ("debounceUpdate" in $$props) $$invalidate(15, debounceUpdate = $$props.debounceUpdate);
		if ("debounceResize" in $$props) $$invalidate(16, debounceResize = $$props.debounceResize);
		if ("dynamic" in $$props) $$invalidate(1, dynamic = $$props.dynamic);
		if ("getComputedCols" in $$props) $$invalidate(2, getComputedCols = $$props.getComputedCols);
		if ("container" in $$props) $$invalidate(3, container = $$props.container);
		if ("xPerPx" in $$props) $$invalidate(4, xPerPx = $$props.xPerPx);
		if ("yPerPx" in $$props) $$invalidate(8, yPerPx = $$props.yPerPx);
		if ("documentWidth" in $$props) documentWidth = $$props.documentWidth;
		if ("containerWidth" in $$props) $$invalidate(20, containerWidth = $$props.containerWidth);
		if ("prevCols" in $$props) $$invalidate(21, prevCols = $$props.prevCols);
		if ("gapX" in $$props) $$invalidate(5, gapX = $$props.gapX);
		if ("gapY" in $$props) $$invalidate(6, gapY = $$props.gapY);
		if ("containerHeight" in $$props) $$invalidate(7, containerHeight = $$props.containerHeight);
	};

	let gapX;
	let gapY;
	let containerHeight;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*gap*/ 8192) {
			 $$invalidate(5, [gapX, gapY] = gap, gapX, ($$invalidate(6, gapY), $$invalidate(13, gap)));
		}

		if ($$self.$$.dirty & /*items, getComputedCols*/ 5) {
			 $$invalidate(7, containerHeight = getContainerHeight(items, yPerPx, getComputedCols));
		}

		if ($$self.$$.dirty & /*prevCols, cols, dynamicCols, containerWidth*/ 3166208) {
			 {
				if (prevCols !== cols && dynamicCols) {
					$$invalidate(4, xPerPx = containerWidth / cols);
				}

				$$invalidate(21, prevCols = cols);
			}
		}
	};

	return [
		items,
		dynamic,
		getComputedCols,
		container,
		xPerPx,
		gapX,
		gapY,
		containerHeight,
		yPerPx,
		pointerup,
		handleRepaint,
		rowHeight,
		cols,
		gap,
		dynamicCols,
		debounceUpdate,
		debounceResize,
		slots,
		div_binding,
		$$scope
	];
}

class Src extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			items: 0,
			rowHeight: 11,
			cols: 12,
			gap: 13,
			dynamicCols: 14,
			debounceUpdate: 15,
			debounceResize: 16,
			dynamic: 1
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Src",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<Src> was created without expected prop 'items'");
		}

		if (/*rowHeight*/ ctx[11] === undefined && !("rowHeight" in props)) {
			console.warn("<Src> was created without expected prop 'rowHeight'");
		}

		if (/*cols*/ ctx[12] === undefined && !("cols" in props)) {
			console.warn("<Src> was created without expected prop 'cols'");
		}
	}

	get items() {
		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rowHeight() {
		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rowHeight(value) {
		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get cols() {
		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set cols(value) {
		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get gap() {
		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set gap(value) {
		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dynamicCols() {
		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dynamicCols(value) {
		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get debounceUpdate() {
		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set debounceUpdate(value) {
		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get debounceResize() {
		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set debounceResize(value) {
		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dynamic() {
		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dynamic(value) {
		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function getRowsCount$1(items, cols) {
  return Math.max(
    ...items.map((val) => {
      const item = val[cols];
      return item?.y + item?.h;
    }),
    1,
  );
}

const makeMatrix$1 = (rows, cols) => Array.from(Array(rows), () => new Array(cols)); // make 2d array

function makeMatrixFromItems(items, _row, _col) {
  let matrix = makeMatrix$1(_row, _col);

  for (var i = 0; i < items.length; i++) {
    const value = items[i][_col];
    const { x, y, h } = value;
    const id = items[i];
    const w = Math.min(_col, value.w);

    for (var j = y; j < y + h; j++) {
      const row = matrix[j];
      for (var k = x; k < x + w; k++) {
        row[k] = { ...value, id };
      }
    }
  }
  return matrix;
}

function findCloseBlocks$1(items, matrix, curObject) {
  const { h, x, y } = curObject;

  const w = Math.min(matrix[0].length, curObject.w);
  const tempR = matrix.slice(y, y + h);

  let result = [];
  for (var i = 0; i < tempR.length; i++) {
    let tempA = tempR[i].slice(x, x + w);
    result = [...result, ...tempA.map((val) => val.id && val.id !== curObject.id && val.id).filter(Boolean)];
  }

  return [...new Set(result)];
}

function makeMatrixFromItemsIgnore$1(items, ignoreList, _row, _col) {
  let matrix = makeMatrix$1(_row, _col);
  for (var i = 0; i < items.length; i++) {
    const value = items[i][_col];
    const id = items[i].id;
    const { x, y, h } = value;
    const w = Math.min(_col, value.w);

    if (ignoreList.indexOf(id) === -1) {
      for (var j = y; j < y + h; j++) {
        const row = matrix[j];
        if (row) {
          for (var k = x; k < x + w; k++) {
            row[k] = { ...value, id };
          }
        }
      }
    }
  }
  return matrix;
}

function findItemsById$1(closeBlocks, items) {
  return items.filter((value) => closeBlocks.indexOf(value.id) !== -1);
}

function findFreeSpaceForItem$1(matrix, item, items = []) {
  const cols = matrix[0].length;
  const w = Math.min(cols, item.w);
  let xNtime = cols - w;

  for (var i = 0; i < matrix.length; i++) {
    const row = matrix[i];
    for (var j = 0; j < xNtime + 1; j++) {
      const sliceA = row.slice(j, j + w);
      const empty = sliceA.every((val) => val === undefined);
      if (empty) {
        const isEmpty = matrix.slice(i, i + item.h).every((a) => a.slice(j, j + w).every((n) => n === undefined));

        if (isEmpty) {
          return { y: i, x: j };
        }
      }
    }
  }

  return {
    y: getRowsCount$1(items, cols),
    x: 0,
  };
}

const getItem$1 = (item, col) => {
  return { ...item[col], id: item.id };
};

const updateItem$1 = (elements, active, position, col) => {
  return elements.map((value) => {
    if (value.id === active.id) {
      return { ...value, [col]: { ...value[col], ...position } };
    }
    return value;
  });
};

function moveItem$1(active, items, cols, original) {
  // Get current item from the breakpoint
  const item = getItem$1(active, cols);
  // Create matrix from the items expect the active
  let matrix = makeMatrixFromItemsIgnore$1(items, [item.id], getRowsCount$1(items, cols), cols);
  // Getting the ids of items under active Array<String>
  const closeBlocks = findCloseBlocks$1(items, matrix, item);
  // Getting the objects of items under active Array<Object>
  let closeObj = findItemsById$1(closeBlocks, items);
  // Getting whenever of these items is fixed
  const fixed = closeObj.find((value) => value[cols].fixed);

  // If found fixed, reset the active to its original position
  if (fixed) return items;

  // Update items
  items = updateItem$1(items, active, item, cols);

  // Create matrix of items expect close elements
  matrix = makeMatrixFromItemsIgnore$1(items, closeBlocks, getRowsCount$1(items, cols), cols);

  // Create temp vars
  let tempItems = items;
  let tempCloseBlocks = closeBlocks;

  // Exclude resolved elements ids in array
  let exclude = [];

  // Iterate over close elements under active item
  closeObj.forEach((item) => {
    // Find position for element
    let position = findFreeSpaceForItem$1(matrix, item[cols], tempItems);
    // Exclude item
    exclude.push(item.id);

    // If position is found
    if (position) {
      // Assign the position to the element in the column
      tempItems = updateItem$1(tempItems, item, position, cols);

      // Recreate ids of elements
      let getIgnoreItems = tempCloseBlocks.filter((value) => exclude.indexOf(value) === -1);

      // Update matrix for next iteration
      matrix = makeMatrixFromItemsIgnore$1(tempItems, getIgnoreItems, getRowsCount$1(tempItems, cols), cols);
    }
  });

  // Return result
  return tempItems;
}

// Helper function
function normalize(items, col) {
  let result = items.slice();

  result.forEach((value) => {
    const getItem = value[col];
    if (!getItem.static) {
      result = moveItem$1(getItem, result, col);
    }
  });

  return result;
}

// Helper function
function adjust(items, col) {
  let matrix = makeMatrix$1(getRowsCount$1(items, col), col);

  let res = [];

  items.forEach((item) => {
    let position = findFreeSpaceForItem$1(matrix, item[col], items);

    res.push({
      ...item,
      [col]: {
        ...item[col],
        ...position,
      },
    });

    matrix = makeMatrixFromItems(res, getRowsCount$1(res, col), col);
  });

  return res;
}

function makeItem(item) {
  const { min = { w: 1, h: 1 }, max } = item;
  return {
    fixed: false,
    resizable: !item.fixed,
    draggable: !item.fixed,
    min: {
      w: Math.max(1, min.w),
      h: Math.max(1, min.h),
    },
    max: { ...max },
    ...item,
  };
}

const gridHelp = {
  normalize(items, col) {
    const rows = getRowsCount$1(items, col);
    return normalize(items, col);
  },

  adjust(items, col) {
    return adjust(items, col);
  },

  item(obj) {
    return makeItem(obj);
  },

  findSpace(item, items, cols) {
    let matrix = makeMatrixFromItems(items, getRowsCount$1(items, cols), cols);

    let position = findFreeSpaceForItem$1(matrix, item[cols], items);
    return position;
  },
};

/* src\components\GridMenu.svelte generated by Svelte v3.29.3 */
const file$4 = "src\\components\\GridMenu.svelte";

// (109:4) {:else}
function create_else_block(ctx) {
	let a;
	let t;

	const block = {
		c: function create() {
			a = element("a");
			t = text("see");
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", { href: true, target: true });
			var a_nodes = children(a);
			t = claim_text(a_nodes, "see");
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "cv");
			attr_dev(a, "target", "_blank");
			add_location(a, file$4, 109, 5, 2137);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(109:4) {:else}",
		ctx
	});

	return block;
}

// (107:4) {#if options[index].info !== 'pdf'}
function create_if_block$2(ctx) {
	let p;
	let t_value = /*options*/ ctx[1][/*index*/ ctx[7]].info + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, t_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "svelte-sy4anr");
			add_location(p, file$4, 107, 5, 2089);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*index*/ 128 && t_value !== (t_value = /*options*/ ctx[1][/*index*/ ctx[7]].info + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(107:4) {#if options[index].info !== 'pdf'}",
		ctx
	});

	return block;
}

// (104:0) <Grid bind:items={items} rowHeight={100} let:item {cols} let:index>
function create_default_slot$2(ctx) {
	let div;
	let h3;
	let t0_value = /*options*/ ctx[1][/*index*/ ctx[7]].title + "";
	let t0;
	let t1;

	function select_block_type(ctx, dirty) {
		if (/*options*/ ctx[1][/*index*/ ctx[7]].info !== "pdf") return create_if_block$2;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			div = element("div");
			h3 = element("h3");
			t0 = text(t0_value);
			t1 = space();
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			h3 = claim_element(div_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, t0_value);
			h3_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h3, "class", "svelte-sy4anr");
			add_location(h3, file$4, 105, 4, 2010);
			attr_dev(div, "class", "content svelte-sy4anr");
			add_location(div, file$4, 104, 2, 1983);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h3);
			append_dev(h3, t0);
			append_dev(div, t1);
			if_block.m(div, null);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*index*/ 128 && t0_value !== (t0_value = /*options*/ ctx[1][/*index*/ ctx[7]].title + "")) set_data_dev(t0, t0_value);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(104:0) <Grid bind:items={items} rowHeight={100} let:item {cols} let:index>",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let h2;
	let t0;
	let t1;
	let grid;
	let updating_items;
	let current;

	function grid_items_binding(value) {
		/*grid_items_binding*/ ctx[3].call(null, value);
	}

	let grid_props = {
		rowHeight: 100,
		cols: /*cols*/ ctx[2],
		$$slots: {
			default: [
				create_default_slot$2,
				({ item, index }) => ({ 6: item, 7: index }),
				({ item, index }) => (item ? 64 : 0) | (index ? 128 : 0)
			]
		},
		$$scope: { ctx }
	};

	if (/*items*/ ctx[0] !== void 0) {
		grid_props.items = /*items*/ ctx[0];
	}

	grid = new Src({ props: grid_props, $$inline: true });
	binding_callbacks.push(() => bind(grid, "items", grid_items_binding));

	const block = {
		c: function create() {
			h2 = element("h2");
			t0 = text("Be flexible, like these boxes!");
			t1 = space();
			create_component(grid.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, "Be flexible, like these boxes!");
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(grid.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "grid-menu-title svelte-sy4anr");
			add_location(h2, file$4, 97, 0, 1835);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t0);
			insert_dev(target, t1, anchor);
			mount_component(grid, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const grid_changes = {};

			if (dirty & /*$$scope, index*/ 384) {
				grid_changes.$$scope = { dirty, ctx };
			}

			if (!updating_items && dirty & /*items*/ 1) {
				updating_items = true;
				grid_changes.items = /*items*/ ctx[0];
				add_flush_callback(() => updating_items = false);
			}

			grid.$set(grid_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(grid.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(grid.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			if (detaching) detach_dev(t1);
			destroy_component(grid, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let $getPersonalLetter;
	validate_store(getPersonalLetter, "getPersonalLetter");
	component_subscribe($$self, getPersonalLetter, $$value => $$invalidate(4, $getPersonalLetter = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GridMenu", slots, []);

	let options = [
		{
			title: "Personal letter",
			info: $getPersonalLetter
		},
		{ title: "CV", info: "pdf" },
		{ title: "Portfolio", icon: "code" },
		{ title: "Travels" },
		{ title: "Contact" }
	];

	const { item } = gridHelp;
	const id = () => "_" + Math.random().toString(36).substr(2, 9);

	let items = [
		{
			id: id(),
			5: item({ x: 0, y: 0, w: 2, h: 6 }),
			3: item({ x: 0, w: 2, h: 2, y: 0 }),
			1: item({ x: 0, y: 0, w: 1, h: 2 })
		},
		{
			id: id(),
			5: item({ x: 2, y: 0, w: 3, h: 2 }),
			3: item({ x: 2, w: 1, h: 2, y: 0 }),
			1: item({ x: 0, y: 2, w: 1, h: 2 })
		},
		{
			id: id(),
			5: item({ x: 2, y: 2, w: 3, h: 2 }),
			3: item({ x: 0, w: 3, h: 2, y: 2 }),
			1: item({ x: 0, y: 4, w: 1, h: 2 })
		}
	];

	const cols = [[1500, 5], [1024, 3], [500, 1]];
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GridMenu> was created with unknown prop '${key}'`);
	});

	function grid_items_binding(value) {
		items = value;
		$$invalidate(0, items);
	}

	$$self.$capture_state = () => ({
		Icon,
		getPersonalLetter,
		options,
		Grid: Src,
		gridHelp,
		item,
		id,
		items,
		cols,
		$getPersonalLetter
	});

	$$self.$inject_state = $$props => {
		if ("options" in $$props) $$invalidate(1, options = $$props.options);
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items, options, cols, grid_items_binding];
}

class GridMenu extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GridMenu",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src\routes\start.svelte generated by Svelte v3.29.3 */
const file$5 = "src\\routes\\start.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	child_ctx[12] = i;
	return child_ctx;
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	child_ctx[9] = i;
	return child_ctx;
}

// (92:7) {#if showStart}
function create_if_block_1$1(ctx) {
	let span;
	let t_value = /*char*/ ctx[10][0] + "";
	let t;
	let span_transition;
	let current;
	let mounted;
	let dispose;

	function introend_handler(...args) {
		return /*introend_handler*/ ctx[5](/*i*/ ctx[12], ...args);
	}

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$5, 92, 8, 2007);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
			current = true;

			if (!mounted) {
				dispose = listen_dev(span, "introend", introend_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: function intro(local) {
			if (current) return;

			if (local) {
				add_render_callback(() => {
					if (!span_transition) span_transition = create_bidirectional_transition(
						span,
						fade,
						{
							delay: /*waitTime*/ ctx[3] + /*waitTime*/ ctx[3] * /*i*/ ctx[12] + /*introLine*/ ctx[7].wait * /*waitTime*/ ctx[3]
						},
						true
					);

					span_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			if (local) {
				if (!span_transition) span_transition = create_bidirectional_transition(
					span,
					fade,
					{
						delay: /*waitTime*/ ctx[3] + /*waitTime*/ ctx[3] * /*i*/ ctx[12] + /*introLine*/ ctx[7].wait * /*waitTime*/ ctx[3]
					},
					false
				);

				span_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (detaching && span_transition) span_transition.end();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(92:7) {#if showStart}",
		ctx
	});

	return block;
}

// (91:6) {#each introLine.text as char, i}
function create_each_block_1(ctx) {
	let if_block_anchor;
	let if_block = /*showStart*/ ctx[0] && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*showStart*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*showStart*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(91:6) {#each introLine.text as char, i}",
		ctx
	});

	return block;
}

// (89:4) {#each introText as introLine, j}
function create_each_block$1(ctx) {
	let h1;
	let t;
	let each_value_1 = /*introLine*/ ctx[7].text;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			h1 = element("h1");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(h1_nodes);
			}

			t = claim_space(h1_nodes);
			h1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "svelte-bh1zbd");
			add_location(h1, file$5, 89, 5, 1928);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(h1, null);
			}

			append_dev(h1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*waitTime, introText, animationDone, showStart*/ 15) {
				each_value_1 = /*introLine*/ ctx[7].text;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(h1, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(89:4) {#each introText as introLine, j}",
		ctx
	});

	return block;
}

// (108:1) {#if animationDone}
function create_if_block$3(ctx) {
	let div;
	let a;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			a = element("a");
			t = text("Who am I?");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			a = claim_element(div_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t = claim_text(a_nodes, "Who am I?");
			a_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "/intro");
			attr_dev(a, "class", "svelte-bh1zbd");
			add_location(a, file$5, 109, 3, 2372);
			attr_dev(div, "class", "icon svelte-bh1zbd");
			add_location(div, file$5, 108, 2, 2349);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, a);
			append_dev(a, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(108:1) {#if animationDone}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let title_value;
	let t0;
	let div2;
	let div1;
	let div0;
	let t1;
	let if_block_anchor;
	document.title = title_value = /*pageTitle*/ ctx[4];
	let each_value = /*introText*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	let if_block = /*animationDone*/ ctx[1] && create_if_block$3(ctx);

	const block = {
		c: function create() {
			t0 = space();
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-a7ezgp\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { style: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "intro-text-container svelte-bh1zbd");
			add_location(div0, file$5, 87, 3, 1848);
			attr_dev(div1, "class", "start-page-background svelte-bh1zbd");
			add_location(div1, file$5, 85, 2, 1806);
			set_style(div2, "height", "105vh");
			add_location(div2, file$5, 84, 1, 1776);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*pageTitle*/ 16 && title_value !== (title_value = /*pageTitle*/ ctx[4])) {
				document.title = title_value;
			}

			if (dirty & /*introText, waitTime, animationDone, showStart*/ 15) {
				each_value = /*introText*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*animationDone*/ ctx[1]) {
				if (if_block) ; else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div2);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Start", slots, []);

	let introText = [
		{ text: "Hi there!", wait: 0 },
		{ text: "I'm William Friefeldt.", wait: 12 },
		{
			text: "And this is my website.",
			wait: 34
		}
	];

	let showStart = false;
	let animationDone = false;
	let waitTime = 200;
	onMount(() => $$invalidate(0, showStart = true));
	let pageTitle = "William Friefeldt";
	let segment = "";
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Start> was created with unknown prop '${key}'`);
	});

	const introend_handler = i => {
		if (i === 22) $$invalidate(1, animationDone = true);
	};

	$$self.$capture_state = () => ({
		fade,
		onMount,
		FaArrowAltCircleDown,
		GridMenu,
		introText,
		showStart,
		animationDone,
		waitTime,
		pageTitle,
		segment
	});

	$$self.$inject_state = $$props => {
		if ("introText" in $$props) $$invalidate(2, introText = $$props.introText);
		if ("showStart" in $$props) $$invalidate(0, showStart = $$props.showStart);
		if ("animationDone" in $$props) $$invalidate(1, animationDone = $$props.animationDone);
		if ("waitTime" in $$props) $$invalidate(3, waitTime = $$props.waitTime);
		if ("pageTitle" in $$props) $$invalidate(4, pageTitle = $$props.pageTitle);
		if ("segment" in $$props) segment = $$props.segment;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [showStart, animationDone, introText, waitTime, pageTitle, introend_handler];
}

class Start extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Start",
			options,
			id: create_fragment$5.name
		});
	}
}

export default Start;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhcnQuYTk4ODNkOTIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtaWNvbnMvaW8vSW9Jb3NDb2RlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0ljb24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbnRlbnQvcGVyc29uYWxMZXR0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWdyaWQvc3JjL3V0aWxzL290aGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1ncmlkL3NyYy91dGlscy9jb250YWluZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWdyaWQvc3JjL3V0aWxzL21hdHJpeC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtZ3JpZC9zcmMvdXRpbHMvaXRlbS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtZ3JpZC9zcmMvTW92ZVJlc2l6ZS9pbmRleC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWdyaWQvc3JjL2luZGV4LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtZ3JpZC9idWlsZC9oZWxwZXIvaW5kZXgubWpzIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvR3JpZE1lbnUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9zdGFydC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICAgICAgaW1wb3J0IEljb25CYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbkJhc2Uuc3ZlbHRlJztcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgIDxJY29uQmFzZSB2aWV3Qm94PVwiMCAwIDUxMiA1MTJcIiB7Li4uJCRwcm9wc30+XG4gICAgICAgICAgPHBhdGggZD1cIk0zMzIgMTQyLjdjLTEuMi0xLjEtMi43LTEuNy00LjEtMS43cy0zIC42LTQuMSAxLjdMMzEwIDE1NS45Yy0xLjIgMS4xLTEuOSAyLjctMS45IDQuMyAwIDEuNi43IDMuMiAxLjkgNC4zbDk1LjggOTEuNS05NS44IDkxLjVjLTEuMiAxLjEtMS45IDIuNy0xLjkgNC4zIDAgMS42LjcgMy4yIDEuOSA0LjNsMTMuOCAxMy4yYzEuMiAxLjEgMi42IDEuNyA0LjEgMS43IDEuNSAwIDMtLjYgNC4xLTEuN2wxMTQuMi0xMDljMS4yLTEuMSAxLjktMi43IDEuOS00LjMgMC0xLjYtLjctMy4yLTEuOS00LjNMMzMyIDE0Mi43ek0yMDQgMTYwLjJjMC0xLjYtLjctMy4yLTEuOS00LjNsLTEzLjgtMTMuMmMtMS4yLTEuMS0yLjctMS43LTQuMS0xLjdzLTMgLjYtNC4xIDEuN2wtMTE0LjIgMTA5Yy0xLjIgMS4xLTEuOSAyLjctMS45IDQuMyAwIDEuNi43IDMuMiAxLjkgNC4zbDExNC4yIDEwOWMxLjIgMS4xIDIuNyAxLjcgNC4xIDEuNyAxLjUgMCAzLS42IDQuMS0xLjdsMTMuOC0xMy4yYzEuMi0xLjEgMS45LTIuNyAxLjktNC4zIDAtMS42LS43LTMuMi0xLjktNC4zTDEwNi4zIDI1Nmw5NS44LTkxLjVjMS4yLTEuMSAxLjktMi43IDEuOS00LjN6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XHJcblxyXG5cdGV4cG9ydCBsZXQgaWNvbk5hbWU7XHJcblxyXG5cdGltcG9ydCBJb0lvc0NvZGUgZnJvbSAnc3ZlbHRlLWljb25zL2lvL0lvSW9zQ29kZS5zdmVsdGUnXHJcblxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHJcblx0ZGl2IDpnbG9iYWwoLmljb24pIHtcclxuXHRcdHdpZHRoOiA1MCU7XHJcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XHJcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZWQ7XHJcblx0fVxyXG5cclxuPC9zdHlsZT5cclxuXHJcbnsjaWYgaWNvbk5hbWUgPT09ICdjb2RlJ30gPGRpdiA+PElvSW9zQ29kZSBjbGFzcz1cImljb25cIi8+PC9kaXY+IHsvaWZ9IiwiaW1wb3J0IHsgcmVhZGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnXHJcblxyXG5jb25zdCBwZXJzb25hbExldHRlciA9IFwiSmFnIGhldGVyIFdpbGxpYW0gb2NoIMOkciAyNiDDpXIgZ2FtbWFsIGZyw6VuIFN0b2NraG9sbS4gTWVkIGV0dCB0aWRpZ3QgaW50cmVzc2UgZsO2ciBtYXRlbWF0aWsgb2NoIGhhdmV0IHN0dWRlcmFkZSBqYWcgcMOlIE1hcmluYSBMw6Ryb3ZlcmtldCBpIFN0b2Nrc3VuZCwgaW5yaWt0bmluZyBuYXR1ciBvY2ggbWFyaW5iaW9sb2dpLiBFZnRlciBneW1uYXNpZXQgam9iYmFkZSBqYWcgZXR0IMOlciwgcMOlIGtyeXNzbmluZ3NmYXJ0eWcgaSBNZWRlbGhhdmV0IG9jaCBzb20gYnJldmLDpHJhcmUsIG9jaCBzZW4gcmVzdGUgamFnIGkgU3lkb3N0YXNpZW4uIEphZyBoYWRlIHNlZGFuIGd5bW5hc2lldCBoYWZ0IHNpa3RldCBww6UgS3VuZ2xpZ2EgVGVrbmlza2EgSMO2Z3Nrb2xhbi4gRMOkcmbDtnIgc8O2a3RlIGphZyB0aWxsIGxpbmplbiBDaXZpbGluZ2VuasO2ciBvY2ggTMOkcmFyZSBlZnRlcnNvbSBqYWcgdmlsbGUga29tYmluZXJhIG1pdHQgdGVrbmlza2EgaW50cmVzc2UgbWVkIG1pbiBzb2NpYWxhIGtvbXBldGVucy4gVW5kZXIgYW5kcmEgw6VyZXQgcMOlIHV0YmlsZG5pbmdlbiB2YWxkZSBqYWcgaW5yaWt0bmluZ2VuIGluZm9ybWF0aW9ucy0gb2NoIGtvbW11bmlrYXRpb25zdGVrbmlrLiBVdGJpbGRuaW5nZW4gZ2VyIG1pZyBtw7ZqbGlnaGV0IGF0dCBqb2JiYSBzb20gZ3ltbmFzaWVsw6RyYXJlIGkgbWF0ZW1hdGlrLCB0ZWtuaWsgb2NoIHByb2dyYW1tZXJpbmcgbWVuIMOkdmVuIHNvbSBjaXZpbGluZ2VuasO2ciBpbm9tIHByb2dyYW1tZXJpbmcgb2NoIElULiBVbmRlciB1dGJpbGRuaW5nZW4gZmljayBqYWcgZ29kYSBrdW5za2FwZXIgaW5vbSBwcm9ncmFtbWVyaW5nLCBmcmFtZsO2cmFsbHQgaW5vbSBmcm9udGVuZC11dHZlY2tsaW5nLiB2YXIgYXR0IHNrcml2YSBsw7ZzbmluZ2FyIGkgTGF0ZXggb2NoIGfDtnJhIGdyYWZlciBpIEphdmFzY3JpcHQgbWVkIGJpYmxpb3Rla2V0IEpTWEdyYXBoLiBFZnRlciBtaXR0IGV4YW1lbnNhcmJldGUgaW5vbSBkaWdpdGFsdCBsw6RyYW5kZSBww6UgTWF0aGxlYWtzIGZpY2sgamFnIGVyYmp1ZGFuZGUgb20gaGVsdGlkc2Fuc3TDpGxsbmluZy4gTWVkIHR2w6Uga3Vyc2VyIGt2YXIgcMOlIHV0YmlsZG5pbmcgdmFsZGUgamFnIGF0dCB0YSBqb2JiZXQgZMOlIGphZyBzw6VnIGRldCBzb20gZW4gc3RvciBtw7ZqbGlnaGV0IGF0dCB1dHZlY2tsYXMgcMOlIGV0dCBzdGFydHVwLiBVbmRlciBtaW5hIGbDtnJzdGEgdHbDpSDDpXIgcMOlIE1hdGhsZWFrcyBoYXIgamFnIGRyaXZpdCBmbGVyIHByb2pla3QsIGJsYW5kYWQgYW5uYXQgcHJvZHVrdHV0dmVja2xpbmdlbiBpbmbDtnIgVVNBIGxhbnNlcmluZ2VuLiBEZXQgaGFyIGdqb3J0IG1pZyBmbHl0YW5kZSBpIHPDpXbDpGwgZm9ybWVsbCBlbmdlbHNrYSBzb20gTGF0ZXguIEphZyBoYXIgZsOldHQgam9iYmEgbWVkIHByb2pla3RsZWRuaW5nIG1lZCBUcmVsbG8gb2NoIGludGVybmEgc3lzdGVtIG1lZCBKYXZhc2NyaXB0LCBIVE1MLCBDU1Mgb2NoIEFuZ3VsYXJKUy4gU2VuYXN0ZSBwcm9qZWt0ZXQgdmFyIGF0dCBzw6R0dGEgdXBwIGVuIE5vZGUtc2VydmVyIGbDtnIgcmVuZHJlcmluZyBhdiBKYXZhc2NyaXB0IHRpbGwgc3RhdGlza2EgU1ZHLWZpbGVyLiBJVC0gdGVhbWV0IGpvYmJhciByZW1vdGUgdmlsa2V0IGhhciBnam9ydCBhdHQgdmlrdGVuIHDDpSBHaXQgb2NoIEJpdGJ1Y2tldCBoYXIgdmFyaXQgc3Rvci4gSmFnIGhhciBsw6RydCBtaWcgYXR0IGdyYW5za2EgYW5kcmFzIGtvZCBzYW10aWRpZ3Qgc29tIGphZyBzasOkbHYga3VubmF0IHV0dmVja2xhcyBnZW5vbSBmZWVkYmFjay4gSmFnIGvDpG5uZXIgbnUgYXR0IGRldCDDpHIgZGFncyBhdHQgdGEgc3RlZ2V0IHRpbGwgYXR0IGJsaSBlbiByZW5vZGxhZCBwcm9ncmFtbWVyYXJlLiBKYWcgaGFyIGbDpXR0IHVwcCBldHQgc3RvcnQgaW50cmVzc2UgZsO2ciBwcm9ncmFtbWVyaW5nIG9jaCBoYXIgc29tIGhvYmJ5cHJvamVrdCBza2FwYXQgaGVtc2lkYW4gaHR0cHM6Ly9wb2Rkc29rLm51LiBEZXQgw6RyIGVuIGhlbXNpZGEgZMOkciBhbnbDpG5kYXJlIGthbiBoaXR0YSBvcmQgb2NoIG1lbmluZ2FyIHNvbSBuw6RtbnMgaSBwb2RjYXN0cy4gRGVuIMOkciBieWdnZCBtZWQgQW5ndWxhckpTLCBGaXJlYmFzZSBzb20gYmFja2VuZCBvY2ggbWVkIEFQSTplciBmcsOlbiBTcG90aWZ5IG9jaCBJdHVuZXMuIFDDpSBkZW4gaMOkciBiYW5hbiB2aWxsIGphZyBmb3J0c8OkdHRhIGtvbWJpbmVyYSBtaW4gdG91Y2ggZsO2ciBkZXNpZ24gbWVkIG1pdHQgbG9naXNrYSBvY2ggdGVrbmlza2EgdMOkbmthbmRlIGbDtnIgYXR0IGzDpHIgbWlnIGRlIHNlbmFzdGUgcmFtdmVya2VuIG9jaCBiaWJsaW90ZWtldCBpbm9tIGZyb250ZW5kIEphZyBzw7ZrZXIgbWlnIGTDpHJmw7ZyIHRpbGwgZXIgZMOlIGphZyB0cm9yIGphZyBrb21tZXIga3VubmEgdXR2ZWNrbGFzIGVub3JtdCBtZW4gw6R2ZW4gYmlkcmEgbXlja2V0IG1lZCBtaW4gcGVkYWdvZ2lza2EgYmFrZ3J1bmQuIERlbiDDpHIgaW50ZSBiYXJhIGFudsOkbmRiYXIgaSBza29sYW4gdXRhbiBpIGFsbGEgZGVsYXIgYXYgc2FtaMOkbGxldC4gTsOlZ290IGphZyBtw6Rya3QgZnJhbWbDtnJhbGx0IHVuZGVyIG1pbmEgw6VyIHDDpSBNYXRobGVha3Mgw6RyIGF0dCBkZXQgw6RyIGzDpHR0YXJlIGbDtnIgbWlnIGF0dCBmw7Zyc3TDpSBlbiBpY2tlIHByb2dyYW1tZXJhciBvY2ggw7Z2ZXJzw6R0dGEgaGVucyB0YW5rYXIgdGlsbCBrb2QuIFNvbSBrb25zdWx0IHRyb3IgamFnIGRldCDDpHIgYnJhIGF0dCB2YXJhIG3DpW5nc2lkaWcgb2NoIGhhIGzDpHR0IGbDtnIgYXR0IHNhbW1hcmJldGEuIEphZyB0eWNrZXIgZGVuIHNvY2lhbGEgZGVsZW4gb2NoIGtvbGxlZ29ybmEgw6RyIGVuIHZpa3RpZyBkZWwgYXYgeXJrZXQuIEVmdGVyIGF0dCBoYSBqb2JiYXQgcMOlIGVuZ2Vsc2thIGLDpWRlIHNrcmlmdGxpZ3Qgb2NoIG11bnRsaWd0IMOkciBqYWcgdsOkbGRpZ3QgYmVrdsOkbSBtZWQgc3Byw6VrZXQgb2NoIGvDpG5uZXIgYXR0IGRldCDDpHZlbiB1dHZlY2tsYXQgbWl0dCBzw6R0dCBhdHQgc2tyaXZhIGtvZC4gSmFnIGhhciBibGl2aXQgbWVyIHN0cnVrdHVyZXJhZCBvY2ggYsOkdHRyZSBww6UgYXR0IHNrcml2YSBsw6R0dGzDpHNsaWcga29kLiBNZWQgZGV0dGEga29tbWVyIGF0dCBqYWcgaGFyIGzDpHR0YXJlIGF0dCB0YSB0aWxsIG1pZyBvY2ggbMOkcmEgbWlnIG55YSBvbXLDpWRlbiBpbm9tIHByb2dyYW1tZXJpbmcgc2rDpGx2bWFudC4gSmFnIHRyb3IgamFnIGtvbW1lciBrdW5uYSBiaWRyYSBtZWQgbnlhIG9jaCBrcmVhdGl2YSBpZMOpZXIgc2FtdCBsZXZlcmFucyBww6UgdXRzYXR0YSBkZWFkbGluZXMuIFVuZGVyIGRldCBzZW5hc3RlIMOlcmV0IGhhciBqYWcgdmVya2xpZ2VuIGbDtnJzdMOldHQgaW5uZWLDtnJkZW4gYXYgaMOlcnQgYXJiZXRlIG9jaCB2YXIgbWFuIGthbiBuw6Ugb20gbWFuIGJhcmEgaGFyIHZpbGphbiBvY2ggZHJpdmV0LiBKYWcgaGFyIGltcGxlbWVudGVyYXQgYsOlZGUgc8O2a2FsZ29yaXRtZXIsIGZvcm11bMOkciBvY2ggbGF5b3V0IGbDtnIgZGF0YSBmcsOlbiB0LmV4LiBBUEktIGFucm9wcC4gRGV0IHRyb3IgamFnIMOkciBmw7ZyZGVsYWt0aWdhIGt1bnNrYXBlciBmw7ZyIGF0dCBwYXNzYSBpIGVyYSB0ZWFtIG9jaCBoasOkbHBhIGbDtnJldGFnIGF0dCBkaWdpdGFsaXNlcmEgc2luIGtvbW11bmlrYXRpb24gb2NoIGt1bmRoYW50ZXJpbmcuIE9tIG5pIGhhciBuw6VncmEgZnLDpWdvciBlbGxlciB2aWxsIHZldGEgbsOlZ290IG1lciDDpHIgZGV0IGJhcmEgYXR0IGjDtnJhIGF2IGVyIVwiO1xyXG5cclxuZXhwb3J0IGxldCBnZXRQZXJzb25hbExldHRlciA9IHJlYWRhYmxlKCBwZXJzb25hbExldHRlciApOyIsImV4cG9ydCBjb25zdCBkZWJvdW5jZSA9IChmbiwgbXMgPSAwKSA9PiB7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gZm4uYXBwbHkodGhpcywgYXJncyksIG1zKTtcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3dzQ291bnQoaXRlbXMsIGNvbHMpIHtcbiAgcmV0dXJuIE1hdGgubWF4KFxuICAgIC4uLml0ZW1zLm1hcCgodmFsKSA9PiB7XG4gICAgICBjb25zdCBpdGVtID0gdmFsW2NvbHNdO1xuICAgICAgcmV0dXJuIGl0ZW0/LnkgKyBpdGVtPy5oO1xuICAgIH0pLFxuICAgIDEsXG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRDb2x1bW4gPSAoY29udGFpbmVyV2lkdGgsIGNvbHVtbnMpID0+IHtcbiAgdHJ5IHtcbiAgICBsZXQgW18sIGNvbHNdID0gY29sdW1uc1xuICAgICAgLnNsaWNlKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maW5kKCh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBbd2lkdGgsIGNvbHNdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjb250YWluZXJXaWR0aCA8PSB3aWR0aDtcbiAgICAgIH0pO1xuICAgIHJldHVybiBjb2xzO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gY29sdW1uc1tjb2x1bW5zLmxlbmd0aCAtIDFdO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgZ2V0Um93c0NvdW50IH0gZnJvbSBcIi4vb3RoZXIuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRhaW5lckhlaWdodChpdGVtcywgeVBlclB4LCBjb2xzKSB7XG4gIHJldHVybiBnZXRSb3dzQ291bnQoaXRlbXMsIGNvbHMpICogeVBlclB4O1xufVxuIiwiaW1wb3J0IHsgZ2V0Um93c0NvdW50IH0gZnJvbSBcIi4vb3RoZXIuanNcIjtcblxuZXhwb3J0IGNvbnN0IG1ha2VNYXRyaXggPSAocm93cywgY29scykgPT4gQXJyYXkuZnJvbShBcnJheShyb3dzKSwgKCkgPT4gbmV3IEFycmF5KGNvbHMpKTsgLy8gbWFrZSAyZCBhcnJheVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZU1hdHJpeEZyb21JdGVtcyhpdGVtcywgX3JvdywgX2NvbCkge1xuICBsZXQgbWF0cml4ID0gbWFrZU1hdHJpeChfcm93LCBfY29sKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdmFsdWUgPSBpdGVtc1tpXVtfY29sXTtcbiAgICBjb25zdCB7IHgsIHksIGggfSA9IHZhbHVlO1xuICAgIGNvbnN0IGlkID0gaXRlbXNbaV07XG4gICAgY29uc3QgdyA9IE1hdGgubWluKF9jb2wsIHZhbHVlLncpO1xuXG4gICAgZm9yICh2YXIgaiA9IHk7IGogPCB5ICsgaDsgaisrKSB7XG4gICAgICBjb25zdCByb3cgPSBtYXRyaXhbal07XG4gICAgICBmb3IgKHZhciBrID0geDsgayA8IHggKyB3OyBrKyspIHtcbiAgICAgICAgcm93W2tdID0geyAuLi52YWx1ZSwgaWQgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdHJpeDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRDbG9zZUJsb2NrcyhpdGVtcywgbWF0cml4LCBjdXJPYmplY3QpIHtcbiAgY29uc3QgeyBoLCB4LCB5IH0gPSBjdXJPYmplY3Q7XG5cbiAgY29uc3QgdyA9IE1hdGgubWluKG1hdHJpeFswXS5sZW5ndGgsIGN1ck9iamVjdC53KTtcbiAgY29uc3QgdGVtcFIgPSBtYXRyaXguc2xpY2UoeSwgeSArIGgpO1xuXG4gIGxldCByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wUi5sZW5ndGg7IGkrKykge1xuICAgIGxldCB0ZW1wQSA9IHRlbXBSW2ldLnNsaWNlKHgsIHggKyB3KTtcbiAgICByZXN1bHQgPSBbLi4ucmVzdWx0LCAuLi50ZW1wQS5tYXAoKHZhbCkgPT4gdmFsLmlkICYmIHZhbC5pZCAhPT0gY3VyT2JqZWN0LmlkICYmIHZhbC5pZCkuZmlsdGVyKEJvb2xlYW4pXTtcbiAgfVxuXG4gIHJldHVybiBbLi4ubmV3IFNldChyZXN1bHQpXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VNYXRyaXhGcm9tSXRlbXNJZ25vcmUoaXRlbXMsIGlnbm9yZUxpc3QsIF9yb3csIF9jb2wpIHtcbiAgbGV0IG1hdHJpeCA9IG1ha2VNYXRyaXgoX3JvdywgX2NvbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IGl0ZW1zW2ldW19jb2xdO1xuICAgIGNvbnN0IGlkID0gaXRlbXNbaV0uaWQ7XG4gICAgY29uc3QgeyB4LCB5LCBoIH0gPSB2YWx1ZTtcbiAgICBjb25zdCB3ID0gTWF0aC5taW4oX2NvbCwgdmFsdWUudyk7XG5cbiAgICBpZiAoaWdub3JlTGlzdC5pbmRleE9mKGlkKSA9PT0gLTEpIHtcbiAgICAgIGZvciAodmFyIGogPSB5OyBqIDwgeSArIGg7IGorKykge1xuICAgICAgICBjb25zdCByb3cgPSBtYXRyaXhbal07XG4gICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICBmb3IgKHZhciBrID0geDsgayA8IHggKyB3OyBrKyspIHtcbiAgICAgICAgICAgIHJvd1trXSA9IHsgLi4udmFsdWUsIGlkIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRyaXg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSXRlbXNCeUlkKGNsb3NlQmxvY2tzLCBpdGVtcykge1xuICByZXR1cm4gaXRlbXMuZmlsdGVyKCh2YWx1ZSkgPT4gY2xvc2VCbG9ja3MuaW5kZXhPZih2YWx1ZS5pZCkgIT09IC0xKTtcbn1cbiIsImltcG9ydCB7IG1ha2VNYXRyaXgsIG1ha2VNYXRyaXhGcm9tSXRlbXNJZ25vcmUsIGZpbmRDbG9zZUJsb2NrcywgZmluZEl0ZW1zQnlJZCwgbWFrZU1hdHJpeEZyb21JdGVtcyB9IGZyb20gXCIuL21hdHJpeC5qc1wiO1xuaW1wb3J0IHsgZ2V0Um93c0NvdW50IH0gZnJvbSBcIi4vb3RoZXIuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEl0ZW1CeUlkKGlkLCBpdGVtcykge1xuICByZXR1cm4gaXRlbXMuZmluZCgodmFsdWUpID0+IHZhbHVlLmlkID09PSBpZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnJlZVNwYWNlRm9ySXRlbShtYXRyaXgsIGl0ZW0sIGl0ZW1zID0gW10pIHtcbiAgY29uc3QgY29scyA9IG1hdHJpeFswXS5sZW5ndGg7XG4gIGNvbnN0IHcgPSBNYXRoLm1pbihjb2xzLCBpdGVtLncpO1xuICBsZXQgeE50aW1lID0gY29scyAtIHc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRyaXgubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByb3cgPSBtYXRyaXhbaV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB4TnRpbWUgKyAxOyBqKyspIHtcbiAgICAgIGNvbnN0IHNsaWNlQSA9IHJvdy5zbGljZShqLCBqICsgdyk7XG4gICAgICBjb25zdCBlbXB0eSA9IHNsaWNlQS5ldmVyeSgodmFsKSA9PiB2YWwgPT09IHVuZGVmaW5lZCk7XG4gICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgY29uc3QgaXNFbXB0eSA9IG1hdHJpeC5zbGljZShpLCBpICsgaXRlbS5oKS5ldmVyeSgoYSkgPT4gYS5zbGljZShqLCBqICsgdykuZXZlcnkoKG4pID0+IG4gPT09IHVuZGVmaW5lZCkpO1xuXG4gICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIHsgeTogaSwgeDogaiB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB5OiBnZXRSb3dzQ291bnQoaXRlbXMsIGNvbHMpLFxuICAgIHg6IDAsXG4gIH07XG59XG5cbmNvbnN0IGdldEl0ZW0gPSAoaXRlbSwgY29sKSA9PiB7XG4gIHJldHVybiB7IC4uLml0ZW1bY29sXSwgaWQ6IGl0ZW0uaWQgfTtcbn07XG5cbmNvbnN0IHVwZGF0ZUl0ZW0gPSAoZWxlbWVudHMsIGFjdGl2ZSwgcG9zaXRpb24sIGNvbCkgPT4ge1xuICByZXR1cm4gZWxlbWVudHMubWFwKCh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZS5pZCA9PT0gYWN0aXZlLmlkKSB7XG4gICAgICByZXR1cm4geyAuLi52YWx1ZSwgW2NvbF06IHsgLi4udmFsdWVbY29sXSwgLi4ucG9zaXRpb24gfSB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVJdGVtKGFjdGl2ZSwgaXRlbXMsIGNvbHMsIG9yaWdpbmFsKSB7XG4gIC8vIEdldCBjdXJyZW50IGl0ZW0gZnJvbSB0aGUgYnJlYWtwb2ludFxuICBjb25zdCBpdGVtID0gZ2V0SXRlbShhY3RpdmUsIGNvbHMpO1xuICAvLyBDcmVhdGUgbWF0cml4IGZyb20gdGhlIGl0ZW1zIGV4cGVjdCB0aGUgYWN0aXZlXG4gIGxldCBtYXRyaXggPSBtYWtlTWF0cml4RnJvbUl0ZW1zSWdub3JlKGl0ZW1zLCBbaXRlbS5pZF0sIGdldFJvd3NDb3VudChpdGVtcywgY29scyksIGNvbHMpO1xuICAvLyBHZXR0aW5nIHRoZSBpZHMgb2YgaXRlbXMgdW5kZXIgYWN0aXZlIEFycmF5PFN0cmluZz5cbiAgY29uc3QgY2xvc2VCbG9ja3MgPSBmaW5kQ2xvc2VCbG9ja3MoaXRlbXMsIG1hdHJpeCwgaXRlbSk7XG4gIC8vIEdldHRpbmcgdGhlIG9iamVjdHMgb2YgaXRlbXMgdW5kZXIgYWN0aXZlIEFycmF5PE9iamVjdD5cbiAgbGV0IGNsb3NlT2JqID0gZmluZEl0ZW1zQnlJZChjbG9zZUJsb2NrcywgaXRlbXMpO1xuICAvLyBHZXR0aW5nIHdoZW5ldmVyIG9mIHRoZXNlIGl0ZW1zIGlzIGZpeGVkXG4gIGNvbnN0IGZpeGVkID0gY2xvc2VPYmouZmluZCgodmFsdWUpID0+IHZhbHVlW2NvbHNdLmZpeGVkKTtcblxuICAvLyBJZiBmb3VuZCBmaXhlZCwgcmVzZXQgdGhlIGFjdGl2ZSB0byBpdHMgb3JpZ2luYWwgcG9zaXRpb25cbiAgaWYgKGZpeGVkKSByZXR1cm4gaXRlbXM7XG5cbiAgLy8gVXBkYXRlIGl0ZW1zXG4gIGl0ZW1zID0gdXBkYXRlSXRlbShpdGVtcywgYWN0aXZlLCBpdGVtLCBjb2xzKTtcblxuICAvLyBDcmVhdGUgbWF0cml4IG9mIGl0ZW1zIGV4cGVjdCBjbG9zZSBlbGVtZW50c1xuICBtYXRyaXggPSBtYWtlTWF0cml4RnJvbUl0ZW1zSWdub3JlKGl0ZW1zLCBjbG9zZUJsb2NrcywgZ2V0Um93c0NvdW50KGl0ZW1zLCBjb2xzKSwgY29scyk7XG5cbiAgLy8gQ3JlYXRlIHRlbXAgdmFyc1xuICBsZXQgdGVtcEl0ZW1zID0gaXRlbXM7XG4gIGxldCB0ZW1wQ2xvc2VCbG9ja3MgPSBjbG9zZUJsb2NrcztcblxuICAvLyBFeGNsdWRlIHJlc29sdmVkIGVsZW1lbnRzIGlkcyBpbiBhcnJheVxuICBsZXQgZXhjbHVkZSA9IFtdO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciBjbG9zZSBlbGVtZW50cyB1bmRlciBhY3RpdmUgaXRlbVxuICBjbG9zZU9iai5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgLy8gRmluZCBwb3NpdGlvbiBmb3IgZWxlbWVudFxuICAgIGxldCBwb3NpdGlvbiA9IGZpbmRGcmVlU3BhY2VGb3JJdGVtKG1hdHJpeCwgaXRlbVtjb2xzXSwgdGVtcEl0ZW1zKTtcbiAgICAvLyBFeGNsdWRlIGl0ZW1cbiAgICBleGNsdWRlLnB1c2goaXRlbS5pZCk7XG5cbiAgICAvLyBJZiBwb3NpdGlvbiBpcyBmb3VuZFxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgLy8gQXNzaWduIHRoZSBwb3NpdGlvbiB0byB0aGUgZWxlbWVudCBpbiB0aGUgY29sdW1uXG4gICAgICB0ZW1wSXRlbXMgPSB1cGRhdGVJdGVtKHRlbXBJdGVtcywgaXRlbSwgcG9zaXRpb24sIGNvbHMpO1xuXG4gICAgICAvLyBSZWNyZWF0ZSBpZHMgb2YgZWxlbWVudHNcbiAgICAgIGxldCBnZXRJZ25vcmVJdGVtcyA9IHRlbXBDbG9zZUJsb2Nrcy5maWx0ZXIoKHZhbHVlKSA9PiBleGNsdWRlLmluZGV4T2YodmFsdWUpID09PSAtMSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBtYXRyaXggZm9yIG5leHQgaXRlcmF0aW9uXG4gICAgICBtYXRyaXggPSBtYWtlTWF0cml4RnJvbUl0ZW1zSWdub3JlKHRlbXBJdGVtcywgZ2V0SWdub3JlSXRlbXMsIGdldFJvd3NDb3VudCh0ZW1wSXRlbXMsIGNvbHMpLCBjb2xzKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFJldHVybiByZXN1bHRcbiAgcmV0dXJuIHRlbXBJdGVtcztcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKGl0ZW1zLCBjb2wpIHtcbiAgbGV0IHJlc3VsdCA9IGl0ZW1zLnNsaWNlKCk7XG5cbiAgcmVzdWx0LmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgZ2V0SXRlbSA9IHZhbHVlW2NvbF07XG4gICAgaWYgKCFnZXRJdGVtLnN0YXRpYykge1xuICAgICAgcmVzdWx0ID0gbW92ZUl0ZW0oZ2V0SXRlbSwgcmVzdWx0LCBjb2wsIHsgLi4uZ2V0SXRlbSB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdChpdGVtcywgY29sKSB7XG4gIGxldCBtYXRyaXggPSBtYWtlTWF0cml4KGdldFJvd3NDb3VudChpdGVtcywgY29sKSwgY29sKTtcblxuICBsZXQgcmVzID0gW107XG5cbiAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGxldCBwb3NpdGlvbiA9IGZpbmRGcmVlU3BhY2VGb3JJdGVtKG1hdHJpeCwgaXRlbVtjb2xdLCBpdGVtcyk7XG5cbiAgICByZXMucHVzaCh7XG4gICAgICAuLi5pdGVtLFxuICAgICAgW2NvbF06IHtcbiAgICAgICAgLi4uaXRlbVtjb2xdLFxuICAgICAgICAuLi5wb3NpdGlvbixcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBtYXRyaXggPSBtYWtlTWF0cml4RnJvbUl0ZW1zKHJlcywgZ2V0Um93c0NvdW50KHJlcywgY29sKSwgY29sKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlcztcbn1cbiIsIjxzdHlsZT5cbiAgLnN2bHQtZ3JpZC1pdGVtIHtcbiAgICB0b3VjaC1hY3Rpb246IG5vbmU7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGJhY2tncm91bmQ6ICNmMWYxZjE7XG4gICAgd2lsbC1jaGFuZ2U6IGF1dG87XG4gICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xuICB9XG5cbiAgLnN2bHQtZ3JpZC1yZXNpemVyIHtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICB3aWR0aDogMjBweDtcbiAgICBoZWlnaHQ6IDIwcHg7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHJpZ2h0OiAwO1xuICAgIGJvdHRvbTogMDtcbiAgICBjdXJzb3I6IHNlLXJlc2l6ZTtcbiAgfVxuICAuc3ZsdC1ncmlkLXJlc2l6ZXI6OmFmdGVyIHtcbiAgICBjb250ZW50OiBcIlwiO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogM3B4O1xuICAgIGJvdHRvbTogM3B4O1xuICAgIHdpZHRoOiA1cHg7XG4gICAgaGVpZ2h0OiA1cHg7XG4gICAgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gIH1cblxuICAubm8tdXNlciB7XG4gICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIC1tb3otYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIC1vLWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAtbXMtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIC13ZWJraXQtdXNlci1kcmFnOiBub25lO1xuICAgIC1tb3otdXNlci1kcmFnOiBub25lO1xuICAgIC1vLXVzZXItZHJhZzogbm9uZTtcbiAgICB1c2VyLWRyYWc6IG5vbmU7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIH1cblxuICAuYWN0aXZlIHtcbiAgICB6LWluZGV4OiAzO1xuICAgIGN1cnNvcjogZ3JhYmJpbmc7XG4gIH1cblxuICAuc2hhZG93LWFjdGl2ZSB7XG4gICAgei1pbmRleDogMjtcbiAgfVxuXG4gIC5zdmx0LWdyaWQtc2hhZG93IHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYmFja2dyb3VuZDogcmVkO1xuICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XG4gICAgYmFja2dyb3VuZDogcGluaztcbiAgICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cblxuICAudHJhbnNpdGlvbiB7XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuMnM7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXZcbiAgb246cG9pbnRlcmRvd249e2l0ZW0/LmN1c3RvbSA/IG51bGwgOiBkcmFnZ2FibGUgJiYgcG9pbnRlcmRvd259XG4gIGNsYXNzPVwic3ZsdC1ncmlkLWl0ZW1cIlxuICBjbGFzczp0cmFuc2l0aW9uPXshYWN0aXZlfVxuICBjbGFzczphY3RpdmVcbiAgY2xhc3M6bm8tdXNlcj17YWN0aXZlfVxuICBzdHlsZT1cIndpZHRoOiB7YWN0aXZlID8gY2xvbmVCb3VuZC53aWR0aCA6IHdpZHRofXB4OyBoZWlnaHQ6e2FjdGl2ZSA/IGNsb25lQm91bmQuaGVpZ2h0IDogaGVpZ2h0fXB4OyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh7YWN0aXZlID8gY2xvbmVCb3VuZC5sZWZ0IDogbGVmdH1weCwge2FjdGl2ZSA/IGNsb25lQm91bmQudG9wIDogdG9wfXB4KTtcIj5cbiAgPHNsb3Qge3BvaW50ZXJkb3dufSAvPlxuICB7I2lmIHJlc2l6YWJsZX1cbiAgICA8ZGl2IGNsYXNzPVwic3ZsdC1ncmlkLXJlc2l6ZXJcIiBvbjpwb2ludGVyZG93bj17cmVzaXplUG9pbnRlckRvd259IC8+XG4gIHsvaWZ9XG48L2Rpdj5cblxueyNpZiBhY3RpdmV9XG4gIDxkaXYgY2xhc3M9XCJzdmx0LWdyaWQtc2hhZG93IHRyYW5zaXRpb24gc2hhZG93LWFjdGl2ZVwiIHN0eWxlPVwiIHdpZHRoOiB7c2hhZG93LncgKiB4UGVyUHggLSBnYXBYICogMn1weDsgaGVpZ2h0OiB7c2hhZG93LmggKiB5UGVyUHggLSBnYXBZICogMn1weDsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoe3NoYWRvdy54ICogeFBlclB4ICsgZ2FwWH1weCwge3NoYWRvdy55ICogeVBlclB4ICsgZ2FwWX1weCk7IFwiIC8+XG57L2lmfVxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIsIGJlZm9yZVVwZGF0ZSB9IGZyb20gXCJzdmVsdGVcIjtcblxuICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIGV4cG9ydCBsZXQgd2lkdGg7XG4gIGV4cG9ydCBsZXQgaGVpZ2h0O1xuICBleHBvcnQgbGV0IGxlZnQ7XG4gIGV4cG9ydCBsZXQgdG9wO1xuXG4gIGV4cG9ydCBsZXQgcmVzaXphYmxlO1xuICBleHBvcnQgbGV0IGRyYWdnYWJsZTtcblxuICBleHBvcnQgbGV0IGlkO1xuXG4gIGV4cG9ydCBsZXQgeFBlclB4O1xuICBleHBvcnQgbGV0IHlQZXJQeDtcblxuICBleHBvcnQgbGV0IGdhcFg7XG4gIGV4cG9ydCBsZXQgZ2FwWTtcbiAgZXhwb3J0IGxldCBpdGVtO1xuICBleHBvcnQgbGV0IGR5bmFtaWM7XG5cbiAgZXhwb3J0IGxldCBtYXg7XG4gIGV4cG9ydCBsZXQgbWluO1xuXG4gIGV4cG9ydCBsZXQgY29scztcblxuICBsZXQgc2hhZG93ID0geyB4OiBpdGVtPy54LCB5OiBpdGVtPy55LCB3OiBpdGVtPy53LCBoOiBpdGVtPy5oIH07XG5cbiAgbGV0IGFjdGl2ZSA9IGZhbHNlO1xuXG4gIGxldCBkZWJvdW5jZSA9IGZhbHNlO1xuXG4gIGxldCBpbml0WCwgaW5pdFk7XG5cbiAgbGV0IHh5UmVmID0geyB4OiBsZWZ0LCB5OiB0b3AgfTtcbiAgbGV0IG5ld1hZID0geyB4OiAwLCB5OiAwIH07XG5cbiAgbGV0IGNsb25lQm91bmQgPSB7IHdpZHRoLCBoZWlnaHQsIHRvcCwgbGVmdCB9O1xuXG4gIGNvbnN0IGluQWN0aXZhdGUgPSAoKSA9PiB7XG4gICAgYWN0aXZlID0gZmFsc2U7XG4gICAgZGlzcGF0Y2goXCJwb2ludGVydXBcIiwge1xuICAgICAgaWQsXG4gICAgfSk7XG4gIH07XG5cbiAgbGV0IHJlcGFpbnQgPSAobGlzdGVuID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IG9uVXBkYXRlID0gIWxpc3RlbiA/IGZhbHNlIDogaW5BY3RpdmF0ZTtcbiAgICBkaXNwYXRjaChcInJlcGFpbnRcIiwge1xuICAgICAgaWQsXG4gICAgICBzaGFkb3csXG4gICAgICBvblVwZGF0ZSxcbiAgICB9KTtcbiAgfTtcblxuICBiZWZvcmVVcGRhdGUoKCkgPT4ge1xuICAgIGlmICh4UGVyUHggJiYgIWRlYm91bmNlKSB7XG4gICAgICB4eVJlZiA9IHsgeDogbGVmdCwgeTogdG9wIH07XG4gICAgICBzaGFkb3cgPSB7IHg6IGl0ZW0/LngsIHk6IGl0ZW0/LnksIHc6IGl0ZW0/LncsIGg6IGl0ZW0/LmggfTtcblxuICAgICAgZGVib3VuY2UgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgcG9pbnRlcmRvd24gPSAoeyBwYWdlWCwgcGFnZVksIGNsaWVudFgsIGNsaWVudFkgfSkgPT4ge1xuICAgIGluaXRYID0gcGFnZVg7XG4gICAgaW5pdFkgPSBwYWdlWTtcblxuICAgIGNsb25lQm91bmQgPSB7IHdpZHRoLCBoZWlnaHQsIHRvcCwgbGVmdCB9O1xuXG4gICAgZGVib3VuY2UgPSBmYWxzZTtcblxuICAgIGFjdGl2ZSA9IHRydWU7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHBvaW50ZXJtb3ZlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVydXApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBwb2ludGVydXApO1xuICB9O1xuXG4gIGNvbnN0IHBvaW50ZXJtb3ZlID0gKHsgcGFnZVgsIHBhZ2VZLCBjbGllbnRYLCBjbGllbnRZIH0pID0+IHtcbiAgICBuZXdYWSA9IHsgeDogaW5pdFggLSBwYWdlWCwgeTogaW5pdFkgLSBwYWdlWSB9O1xuICAgIGNsb25lQm91bmQubGVmdCA9IHh5UmVmLnggLSBuZXdYWS54O1xuICAgIGNsb25lQm91bmQudG9wID0geHlSZWYueSAtIG5ld1hZLnk7XG5cbiAgICBsZXQgZ3JpZFggPSBNYXRoLnJvdW5kKGNsb25lQm91bmQubGVmdCAvIHhQZXJQeCk7XG4gICAgbGV0IGdyaWRZID0gTWF0aC5yb3VuZChjbG9uZUJvdW5kLnRvcCAvIHlQZXJQeCk7XG5cbiAgICBzaGFkb3cueCA9IE1hdGgubWF4KE1hdGgubWluKGdyaWRYLCBjb2xzIC0gc2hhZG93LncpLCAwKTtcbiAgICBzaGFkb3cueSA9IE1hdGgubWF4KGdyaWRZLCAwKTtcblxuICAgIGlmIChkeW5hbWljKSByZXBhaW50KGZhbHNlKTtcbiAgfTtcblxuICBjb25zdCBwb2ludGVydXAgPSAoZSkgPT4ge1xuICAgIHh5UmVmLnggLT0gbmV3WFkueDtcbiAgICB4eVJlZi55IC09IG5ld1hZLnk7XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHBvaW50ZXJkb3duKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHBvaW50ZXJtb3ZlKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVydXApO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBwb2ludGVydXApO1xuXG4gICAgcmVwYWludCgpO1xuICB9O1xuXG4gIC8vIFJlc2l6ZVxuXG4gIGxldCByZXNpemVJbml0WCwgcmVzaXplSW5pdFk7XG5cbiAgbGV0IGluaXRpYWxXaWR0aCA9IDA7XG4gIGxldCBpbml0aWFsSGVpZ2h0ID0gMDtcblxuICBjb25zdCByZXNpemVQb2ludGVyRG93biA9IChlKSA9PiB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBjb25zdCB7IHBhZ2VYLCBwYWdlWSB9ID0gZTtcblxuICAgIHJlc2l6ZUluaXRYID0gcGFnZVg7XG4gICAgcmVzaXplSW5pdFkgPSBwYWdlWTtcblxuICAgIGluaXRpYWxXaWR0aCA9IHdpZHRoO1xuICAgIGluaXRpYWxIZWlnaHQgPSBoZWlnaHQ7XG4gICAgY2xvbmVCb3VuZCA9IHsgd2lkdGgsIGhlaWdodCwgdG9wLCBsZWZ0IH07XG5cbiAgICBhY3RpdmUgPSB0cnVlO1xuICAgIGNvbnN0IHsgeCwgeSwgdywgaCB9ID0gaXRlbTtcbiAgICBzaGFkb3cgPSB7IHgsIHksIHcsIGggfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgcmVzaXplUG9pbnRlck1vdmUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHJlc2l6ZVBvaW50ZXJVcCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIHJlc2l6ZVBvaW50ZXJVcCk7XG4gIH07XG5cbiAgY29uc3QgcmVzaXplUG9pbnRlck1vdmUgPSAoeyBwYWdlWCwgcGFnZVkgfSkgPT4ge1xuICAgIGNsb25lQm91bmQud2lkdGggPSBpbml0aWFsV2lkdGggKyBwYWdlWCAtIHJlc2l6ZUluaXRYO1xuICAgIGNsb25lQm91bmQuaGVpZ2h0ID0gaW5pdGlhbEhlaWdodCArIHBhZ2VZIC0gcmVzaXplSW5pdFk7XG5cbiAgICBzaGFkb3cudyA9IE1hdGgucm91bmQoY2xvbmVCb3VuZC53aWR0aCAvIHhQZXJQeCk7XG4gICAgc2hhZG93LmggPSBNYXRoLnJvdW5kKGNsb25lQm91bmQuaGVpZ2h0IC8geVBlclB4KTtcblxuICAgIGxldCBtYXhXaWR0aCA9IE1hdGgubWluKG1heC53LCBjb2xzKSB8fCBjb2xzO1xuXG4gICAgc2hhZG93LncgPSBNYXRoLm1heChNYXRoLm1pbihtYXhXaWR0aCwgc2hhZG93LncpLCBtaW4udyk7XG4gICAgc2hhZG93LmggPSBNYXRoLm1heChzaGFkb3cuaCwgbWluLmgpO1xuXG4gICAgaWYgKG1heC5oKSB7XG4gICAgICBzaGFkb3cuaCA9IE1hdGgubWluKG1heC5oLCBzaGFkb3cuaCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlc2l6ZVBvaW50ZXJVcCA9IChlKSA9PiB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHJlcGFpbnQoKTtcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgcmVzaXplUG9pbnRlck1vdmUpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHJlc2l6ZVBvaW50ZXJVcCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIHJlc2l6ZVBvaW50ZXJVcCk7XG4gIH07XG48L3NjcmlwdD5cbiIsIjxzdHlsZT5cbiAgLnN2bHQtZ3JpZC1jb250YWluZXIge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgfVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cInN2bHQtZ3JpZC1jb250YWluZXJcIiBzdHlsZT1cImhlaWdodDoge2NvbnRhaW5lckhlaWdodH1weFwiIGJpbmQ6dGhpcz17Y29udGFpbmVyfT5cbiAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW0sIGkgKGl0ZW0uaWQpfVxuICAgIDxNb3ZlUmVzaXplXG4gICAgICBvbjpyZXBhaW50PXtoYW5kbGVSZXBhaW50fVxuICAgICAgb246cG9pbnRlcnVwPXtwb2ludGVydXB9XG4gICAgICBpZD17aXRlbS5pZH1cbiAgICAgIGluZGV4PXtpfVxuICAgICAgcmVzaXphYmxlPXtpdGVtW2dldENvbXB1dGVkQ29sc10/LnJlc2l6YWJsZX1cbiAgICAgIGRyYWdnYWJsZT17aXRlbVtnZXRDb21wdXRlZENvbHNdPy5kcmFnZ2FibGV9XG4gICAgICB7eFBlclB4fVxuICAgICAge3lQZXJQeH1cbiAgICAgIHdpZHRoPXtNYXRoLm1pbihnZXRDb21wdXRlZENvbHMsIGl0ZW1bZ2V0Q29tcHV0ZWRDb2xzXT8udykgKiB4UGVyUHggLSBnYXBYICogMn1cbiAgICAgIGhlaWdodD17aXRlbVtnZXRDb21wdXRlZENvbHNdPy5oICogeVBlclB4IC0gZ2FwWCAqIDJ9XG4gICAgICB0b3A9e2l0ZW1bZ2V0Q29tcHV0ZWRDb2xzXT8ueSAqIHlQZXJQeCArIGdhcFl9XG4gICAgICBsZWZ0PXtpdGVtW2dldENvbXB1dGVkQ29sc10/LnggKiB4UGVyUHggKyBnYXBYfVxuICAgICAgaXRlbT17aXRlbVtnZXRDb21wdXRlZENvbHNdfVxuICAgICAgbWluPXtpdGVtW2dldENvbXB1dGVkQ29sc10/Lm1pbn1cbiAgICAgIG1heD17aXRlbVtnZXRDb21wdXRlZENvbHNdPy5tYXh9XG4gICAgICB7ZHluYW1pY31cbiAgICAgIGNvbHM9e2dldENvbXB1dGVkQ29sc31cbiAgICAgIHtnYXBYfVxuICAgICAge2dhcFl9XG4gICAgICBsZXQ6cG9pbnRlcmRvd24+XG4gICAgICA8c2xvdCB7cG9pbnRlcmRvd259IGRhdGFJdGVtPXtpdGVtfSBpdGVtPXtpdGVtW2dldENvbXB1dGVkQ29sc119IGluZGV4PXtpfSAvPlxuICAgIDwvTW92ZVJlc2l6ZT5cbiAgey9lYWNofVxuPC9kaXY+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCB7IGdldENvbnRhaW5lckhlaWdodCB9IGZyb20gXCIuL3V0aWxzL2NvbnRhaW5lci5qc1wiO1xuICBpbXBvcnQgeyBtb3ZlSXRlbSwgZ2V0SXRlbUJ5SWQgfSBmcm9tIFwiLi91dGlscy9pdGVtLmpzXCI7XG4gIGltcG9ydCB7IG9uTW91bnQsIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IHsgZGVib3VuY2UsIGdldENvbHVtbiB9IGZyb20gXCIuL3V0aWxzL290aGVyLmpzXCI7XG5cbiAgaW1wb3J0IE1vdmVSZXNpemUgZnJvbSBcIi4vTW92ZVJlc2l6ZS9pbmRleC5zdmVsdGVcIjtcblxuICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIGV4cG9ydCBsZXQgaXRlbXM7XG4gIGV4cG9ydCBsZXQgcm93SGVpZ2h0O1xuICBleHBvcnQgbGV0IGNvbHM7XG4gIGV4cG9ydCBsZXQgZ2FwID0gWzEwLCAxMF07XG4gIGV4cG9ydCBsZXQgZHluYW1pY0NvbHMgPSB0cnVlO1xuXG4gIGV4cG9ydCBsZXQgZGVib3VuY2VVcGRhdGUgPSAxMDA7XG4gIGV4cG9ydCBsZXQgZGVib3VuY2VSZXNpemUgPSAxMDA7XG4gIGV4cG9ydCBsZXQgZHluYW1pYyA9IGZhbHNlO1xuXG4gIGxldCBnZXRDb21wdXRlZENvbHM7XG5cbiAgbGV0IGNvbnRhaW5lcjtcblxuICAkOiBbZ2FwWCwgZ2FwWV0gPSBnYXA7XG5cbiAgbGV0IHhQZXJQeCA9IDA7XG4gIGxldCB5UGVyUHggPSByb3dIZWlnaHQ7XG5cbiAgbGV0IGRvY3VtZW50V2lkdGg7XG5cbiAgbGV0IGNvbnRhaW5lcldpZHRoO1xuXG4gICQ6IGNvbnRhaW5lckhlaWdodCA9IGdldENvbnRhaW5lckhlaWdodChpdGVtcywgeVBlclB4LCBnZXRDb21wdXRlZENvbHMpO1xuXG4gIGxldCBwcmV2Q29scztcblxuICAkOiB7XG4gICAgaWYgKHByZXZDb2xzICE9PSBjb2xzICYmIGR5bmFtaWNDb2xzKSB7XG4gICAgICB4UGVyUHggPSBjb250YWluZXJXaWR0aCAvIGNvbHM7XG4gICAgfVxuICAgIHByZXZDb2xzID0gY29scztcbiAgfVxuXG4gIGNvbnN0IHBvaW50ZXJ1cCA9IChldikgPT4ge1xuICAgIGRpc3BhdGNoKFwicG9pbnRlcnVwXCIsIHtcbiAgICAgIGlkOiBldi5kZXRhaWwuaWQsXG4gICAgICBjb2xzOiBnZXRDb21wdXRlZENvbHMsXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3Qgb25SZXNpemUgPSBkZWJvdW5jZSgoKSA9PiB7XG4gICAgZGlzcGF0Y2goXCJyZXNpemVcIiwge1xuICAgICAgY29sczogZ2V0Q29tcHV0ZWRDb2xzLFxuICAgICAgeFBlclB4LFxuICAgICAgeVBlclB4LFxuICAgICAgd2lkdGg6IGNvbnRhaW5lcldpZHRoLFxuICAgIH0pO1xuICB9LCBkZWJvdW5jZVJlc2l6ZSk7XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgY29uc3Qgc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICBsZXQgd2lkdGggPSBlbnRyaWVzWzBdLmNvbnRlbnRSZWN0LndpZHRoO1xuXG4gICAgICBpZiAod2lkdGggPT09IGNvbnRhaW5lcldpZHRoKSByZXR1cm47XG5cbiAgICAgIGdldENvbXB1dGVkQ29scyA9IGdldENvbHVtbih3aWR0aCwgY29scyk7XG5cbiAgICAgIHhQZXJQeCA9IHdpZHRoIC8gZ2V0Q29tcHV0ZWRDb2xzO1xuXG4gICAgICBpZiAoIWNvbnRhaW5lcldpZHRoKSB7XG4gICAgICAgIGRpc3BhdGNoKFwibW91bnRcIiwge1xuICAgICAgICAgIGNvbHM6IGdldENvbXB1dGVkQ29scyxcbiAgICAgICAgICB4UGVyUHgsXG4gICAgICAgICAgeVBlclB4LCAvLyBzYW1lIGFzIHJvd0hlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uUmVzaXplKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRhaW5lcldpZHRoID0gd2lkdGg7XG4gICAgfSk7XG5cbiAgICBzaXplT2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIpO1xuXG4gICAgcmV0dXJuICgpID0+IHNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH0pO1xuXG4gIGNvbnN0IHVwZGF0ZU1hdHJpeCA9ICh7IGRldGFpbCB9KSA9PiB7XG4gICAgbGV0IGFjdGl2ZUl0ZW0gPSBnZXRJdGVtQnlJZChkZXRhaWwuaWQsIGl0ZW1zKTtcblxuICAgIGlmIChhY3RpdmVJdGVtKSB7XG4gICAgICBhY3RpdmVJdGVtID0ge1xuICAgICAgICAuLi5hY3RpdmVJdGVtLFxuICAgICAgICBbZ2V0Q29tcHV0ZWRDb2xzXToge1xuICAgICAgICAgIC4uLmFjdGl2ZUl0ZW1bZ2V0Q29tcHV0ZWRDb2xzXSxcbiAgICAgICAgICAuLi5kZXRhaWwuc2hhZG93LFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgaXRlbXMgPSBtb3ZlSXRlbShhY3RpdmVJdGVtLCBpdGVtcywgZ2V0Q29tcHV0ZWRDb2xzLCBnZXRJdGVtQnlJZChkZXRhaWwuaWQsIGl0ZW1zKSk7XG5cbiAgICAgIGlmIChkZXRhaWwub25VcGRhdGUpIGRldGFpbC5vblVwZGF0ZSgpO1xuXG4gICAgICBkaXNwYXRjaChcImNoYW5nZVwiLCB7XG4gICAgICAgIHVuc2FmZUl0ZW06IGFjdGl2ZUl0ZW0sXG4gICAgICAgIGlkOiBhY3RpdmVJdGVtLmlkLFxuICAgICAgICBjb2xzOiBnZXRDb21wdXRlZENvbHMsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUmVwYWludCA9IGRlYm91bmNlKHVwZGF0ZU1hdHJpeCwgZGVib3VuY2VVcGRhdGUpO1xuPC9zY3JpcHQ+XG4iLCJmdW5jdGlvbiBnZXRSb3dzQ291bnQoaXRlbXMsIGNvbHMpIHtcbiAgcmV0dXJuIE1hdGgubWF4KFxuICAgIC4uLml0ZW1zLm1hcCgodmFsKSA9PiB7XG4gICAgICBjb25zdCBpdGVtID0gdmFsW2NvbHNdO1xuICAgICAgcmV0dXJuIGl0ZW0/LnkgKyBpdGVtPy5oO1xuICAgIH0pLFxuICAgIDEsXG4gICk7XG59XG5cbmNvbnN0IG1ha2VNYXRyaXggPSAocm93cywgY29scykgPT4gQXJyYXkuZnJvbShBcnJheShyb3dzKSwgKCkgPT4gbmV3IEFycmF5KGNvbHMpKTsgLy8gbWFrZSAyZCBhcnJheVxuXG5mdW5jdGlvbiBtYWtlTWF0cml4RnJvbUl0ZW1zKGl0ZW1zLCBfcm93LCBfY29sKSB7XG4gIGxldCBtYXRyaXggPSBtYWtlTWF0cml4KF9yb3csIF9jb2wpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IGl0ZW1zW2ldW19jb2xdO1xuICAgIGNvbnN0IHsgeCwgeSwgaCB9ID0gdmFsdWU7XG4gICAgY29uc3QgaWQgPSBpdGVtc1tpXTtcbiAgICBjb25zdCB3ID0gTWF0aC5taW4oX2NvbCwgdmFsdWUudyk7XG5cbiAgICBmb3IgKHZhciBqID0geTsgaiA8IHkgKyBoOyBqKyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IG1hdHJpeFtqXTtcbiAgICAgIGZvciAodmFyIGsgPSB4OyBrIDwgeCArIHc7IGsrKykge1xuICAgICAgICByb3dba10gPSB7IC4uLnZhbHVlLCBpZCB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0cml4O1xufVxuXG5mdW5jdGlvbiBmaW5kQ2xvc2VCbG9ja3MoaXRlbXMsIG1hdHJpeCwgY3VyT2JqZWN0KSB7XG4gIGNvbnN0IHsgaCwgeCwgeSB9ID0gY3VyT2JqZWN0O1xuXG4gIGNvbnN0IHcgPSBNYXRoLm1pbihtYXRyaXhbMF0ubGVuZ3RoLCBjdXJPYmplY3Qudyk7XG4gIGNvbnN0IHRlbXBSID0gbWF0cml4LnNsaWNlKHksIHkgKyBoKTtcblxuICBsZXQgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcFIubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgdGVtcEEgPSB0ZW1wUltpXS5zbGljZSh4LCB4ICsgdyk7XG4gICAgcmVzdWx0ID0gWy4uLnJlc3VsdCwgLi4udGVtcEEubWFwKCh2YWwpID0+IHZhbC5pZCAmJiB2YWwuaWQgIT09IGN1ck9iamVjdC5pZCAmJiB2YWwuaWQpLmZpbHRlcihCb29sZWFuKV07XG4gIH1cblxuICByZXR1cm4gWy4uLm5ldyBTZXQocmVzdWx0KV07XG59XG5cbmZ1bmN0aW9uIG1ha2VNYXRyaXhGcm9tSXRlbXNJZ25vcmUoaXRlbXMsIGlnbm9yZUxpc3QsIF9yb3csIF9jb2wpIHtcbiAgbGV0IG1hdHJpeCA9IG1ha2VNYXRyaXgoX3JvdywgX2NvbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IGl0ZW1zW2ldW19jb2xdO1xuICAgIGNvbnN0IGlkID0gaXRlbXNbaV0uaWQ7XG4gICAgY29uc3QgeyB4LCB5LCBoIH0gPSB2YWx1ZTtcbiAgICBjb25zdCB3ID0gTWF0aC5taW4oX2NvbCwgdmFsdWUudyk7XG5cbiAgICBpZiAoaWdub3JlTGlzdC5pbmRleE9mKGlkKSA9PT0gLTEpIHtcbiAgICAgIGZvciAodmFyIGogPSB5OyBqIDwgeSArIGg7IGorKykge1xuICAgICAgICBjb25zdCByb3cgPSBtYXRyaXhbal07XG4gICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICBmb3IgKHZhciBrID0geDsgayA8IHggKyB3OyBrKyspIHtcbiAgICAgICAgICAgIHJvd1trXSA9IHsgLi4udmFsdWUsIGlkIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRyaXg7XG59XG5cbmZ1bmN0aW9uIGZpbmRJdGVtc0J5SWQoY2xvc2VCbG9ja3MsIGl0ZW1zKSB7XG4gIHJldHVybiBpdGVtcy5maWx0ZXIoKHZhbHVlKSA9PiBjbG9zZUJsb2Nrcy5pbmRleE9mKHZhbHVlLmlkKSAhPT0gLTEpO1xufVxuXG5mdW5jdGlvbiBmaW5kRnJlZVNwYWNlRm9ySXRlbShtYXRyaXgsIGl0ZW0sIGl0ZW1zID0gW10pIHtcbiAgY29uc3QgY29scyA9IG1hdHJpeFswXS5sZW5ndGg7XG4gIGNvbnN0IHcgPSBNYXRoLm1pbihjb2xzLCBpdGVtLncpO1xuICBsZXQgeE50aW1lID0gY29scyAtIHc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRyaXgubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByb3cgPSBtYXRyaXhbaV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB4TnRpbWUgKyAxOyBqKyspIHtcbiAgICAgIGNvbnN0IHNsaWNlQSA9IHJvdy5zbGljZShqLCBqICsgdyk7XG4gICAgICBjb25zdCBlbXB0eSA9IHNsaWNlQS5ldmVyeSgodmFsKSA9PiB2YWwgPT09IHVuZGVmaW5lZCk7XG4gICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgY29uc3QgaXNFbXB0eSA9IG1hdHJpeC5zbGljZShpLCBpICsgaXRlbS5oKS5ldmVyeSgoYSkgPT4gYS5zbGljZShqLCBqICsgdykuZXZlcnkoKG4pID0+IG4gPT09IHVuZGVmaW5lZCkpO1xuXG4gICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIHsgeTogaSwgeDogaiB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB5OiBnZXRSb3dzQ291bnQoaXRlbXMsIGNvbHMpLFxuICAgIHg6IDAsXG4gIH07XG59XG5cbmNvbnN0IGdldEl0ZW0gPSAoaXRlbSwgY29sKSA9PiB7XG4gIHJldHVybiB7IC4uLml0ZW1bY29sXSwgaWQ6IGl0ZW0uaWQgfTtcbn07XG5cbmNvbnN0IHVwZGF0ZUl0ZW0gPSAoZWxlbWVudHMsIGFjdGl2ZSwgcG9zaXRpb24sIGNvbCkgPT4ge1xuICByZXR1cm4gZWxlbWVudHMubWFwKCh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZS5pZCA9PT0gYWN0aXZlLmlkKSB7XG4gICAgICByZXR1cm4geyAuLi52YWx1ZSwgW2NvbF06IHsgLi4udmFsdWVbY29sXSwgLi4ucG9zaXRpb24gfSB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gbW92ZUl0ZW0oYWN0aXZlLCBpdGVtcywgY29scywgb3JpZ2luYWwpIHtcbiAgLy8gR2V0IGN1cnJlbnQgaXRlbSBmcm9tIHRoZSBicmVha3BvaW50XG4gIGNvbnN0IGl0ZW0gPSBnZXRJdGVtKGFjdGl2ZSwgY29scyk7XG4gIC8vIENyZWF0ZSBtYXRyaXggZnJvbSB0aGUgaXRlbXMgZXhwZWN0IHRoZSBhY3RpdmVcbiAgbGV0IG1hdHJpeCA9IG1ha2VNYXRyaXhGcm9tSXRlbXNJZ25vcmUoaXRlbXMsIFtpdGVtLmlkXSwgZ2V0Um93c0NvdW50KGl0ZW1zLCBjb2xzKSwgY29scyk7XG4gIC8vIEdldHRpbmcgdGhlIGlkcyBvZiBpdGVtcyB1bmRlciBhY3RpdmUgQXJyYXk8U3RyaW5nPlxuICBjb25zdCBjbG9zZUJsb2NrcyA9IGZpbmRDbG9zZUJsb2NrcyhpdGVtcywgbWF0cml4LCBpdGVtKTtcbiAgLy8gR2V0dGluZyB0aGUgb2JqZWN0cyBvZiBpdGVtcyB1bmRlciBhY3RpdmUgQXJyYXk8T2JqZWN0PlxuICBsZXQgY2xvc2VPYmogPSBmaW5kSXRlbXNCeUlkKGNsb3NlQmxvY2tzLCBpdGVtcyk7XG4gIC8vIEdldHRpbmcgd2hlbmV2ZXIgb2YgdGhlc2UgaXRlbXMgaXMgZml4ZWRcbiAgY29uc3QgZml4ZWQgPSBjbG9zZU9iai5maW5kKCh2YWx1ZSkgPT4gdmFsdWVbY29sc10uZml4ZWQpO1xuXG4gIC8vIElmIGZvdW5kIGZpeGVkLCByZXNldCB0aGUgYWN0aXZlIHRvIGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuICBpZiAoZml4ZWQpIHJldHVybiBpdGVtcztcblxuICAvLyBVcGRhdGUgaXRlbXNcbiAgaXRlbXMgPSB1cGRhdGVJdGVtKGl0ZW1zLCBhY3RpdmUsIGl0ZW0sIGNvbHMpO1xuXG4gIC8vIENyZWF0ZSBtYXRyaXggb2YgaXRlbXMgZXhwZWN0IGNsb3NlIGVsZW1lbnRzXG4gIG1hdHJpeCA9IG1ha2VNYXRyaXhGcm9tSXRlbXNJZ25vcmUoaXRlbXMsIGNsb3NlQmxvY2tzLCBnZXRSb3dzQ291bnQoaXRlbXMsIGNvbHMpLCBjb2xzKTtcblxuICAvLyBDcmVhdGUgdGVtcCB2YXJzXG4gIGxldCB0ZW1wSXRlbXMgPSBpdGVtcztcbiAgbGV0IHRlbXBDbG9zZUJsb2NrcyA9IGNsb3NlQmxvY2tzO1xuXG4gIC8vIEV4Y2x1ZGUgcmVzb2x2ZWQgZWxlbWVudHMgaWRzIGluIGFycmF5XG4gIGxldCBleGNsdWRlID0gW107XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIGNsb3NlIGVsZW1lbnRzIHVuZGVyIGFjdGl2ZSBpdGVtXG4gIGNsb3NlT2JqLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAvLyBGaW5kIHBvc2l0aW9uIGZvciBlbGVtZW50XG4gICAgbGV0IHBvc2l0aW9uID0gZmluZEZyZWVTcGFjZUZvckl0ZW0obWF0cml4LCBpdGVtW2NvbHNdLCB0ZW1wSXRlbXMpO1xuICAgIC8vIEV4Y2x1ZGUgaXRlbVxuICAgIGV4Y2x1ZGUucHVzaChpdGVtLmlkKTtcblxuICAgIC8vIElmIHBvc2l0aW9uIGlzIGZvdW5kXG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHBvc2l0aW9uIHRvIHRoZSBlbGVtZW50IGluIHRoZSBjb2x1bW5cbiAgICAgIHRlbXBJdGVtcyA9IHVwZGF0ZUl0ZW0odGVtcEl0ZW1zLCBpdGVtLCBwb3NpdGlvbiwgY29scyk7XG5cbiAgICAgIC8vIFJlY3JlYXRlIGlkcyBvZiBlbGVtZW50c1xuICAgICAgbGV0IGdldElnbm9yZUl0ZW1zID0gdGVtcENsb3NlQmxvY2tzLmZpbHRlcigodmFsdWUpID0+IGV4Y2x1ZGUuaW5kZXhPZih2YWx1ZSkgPT09IC0xKTtcblxuICAgICAgLy8gVXBkYXRlIG1hdHJpeCBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgIG1hdHJpeCA9IG1ha2VNYXRyaXhGcm9tSXRlbXNJZ25vcmUodGVtcEl0ZW1zLCBnZXRJZ25vcmVJdGVtcywgZ2V0Um93c0NvdW50KHRlbXBJdGVtcywgY29scyksIGNvbHMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gUmV0dXJuIHJlc3VsdFxuICByZXR1cm4gdGVtcEl0ZW1zO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25cbmZ1bmN0aW9uIG5vcm1hbGl6ZShpdGVtcywgY29sKSB7XG4gIGxldCByZXN1bHQgPSBpdGVtcy5zbGljZSgpO1xuXG4gIHJlc3VsdC5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGdldEl0ZW0gPSB2YWx1ZVtjb2xdO1xuICAgIGlmICghZ2V0SXRlbS5zdGF0aWMpIHtcbiAgICAgIHJlc3VsdCA9IG1vdmVJdGVtKGdldEl0ZW0sIHJlc3VsdCwgY29sKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvblxuZnVuY3Rpb24gYWRqdXN0KGl0ZW1zLCBjb2wpIHtcbiAgbGV0IG1hdHJpeCA9IG1ha2VNYXRyaXgoZ2V0Um93c0NvdW50KGl0ZW1zLCBjb2wpLCBjb2wpO1xuXG4gIGxldCByZXMgPSBbXTtcblxuICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgbGV0IHBvc2l0aW9uID0gZmluZEZyZWVTcGFjZUZvckl0ZW0obWF0cml4LCBpdGVtW2NvbF0sIGl0ZW1zKTtcblxuICAgIHJlcy5wdXNoKHtcbiAgICAgIC4uLml0ZW0sXG4gICAgICBbY29sXToge1xuICAgICAgICAuLi5pdGVtW2NvbF0sXG4gICAgICAgIC4uLnBvc2l0aW9uLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIG1hdHJpeCA9IG1ha2VNYXRyaXhGcm9tSXRlbXMocmVzLCBnZXRSb3dzQ291bnQocmVzLCBjb2wpLCBjb2wpO1xuICB9KTtcblxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBtYWtlSXRlbShpdGVtKSB7XG4gIGNvbnN0IHsgbWluID0geyB3OiAxLCBoOiAxIH0sIG1heCB9ID0gaXRlbTtcbiAgcmV0dXJuIHtcbiAgICBmaXhlZDogZmFsc2UsXG4gICAgcmVzaXphYmxlOiAhaXRlbS5maXhlZCxcbiAgICBkcmFnZ2FibGU6ICFpdGVtLmZpeGVkLFxuICAgIG1pbjoge1xuICAgICAgdzogTWF0aC5tYXgoMSwgbWluLncpLFxuICAgICAgaDogTWF0aC5tYXgoMSwgbWluLmgpLFxuICAgIH0sXG4gICAgbWF4OiB7IC4uLm1heCB9LFxuICAgIC4uLml0ZW0sXG4gIH07XG59XG5cbmNvbnN0IGdyaWRIZWxwID0ge1xuICBub3JtYWxpemUoaXRlbXMsIGNvbCkge1xuICAgIGNvbnN0IHJvd3MgPSBnZXRSb3dzQ291bnQoaXRlbXMsIGNvbCk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZShpdGVtcywgY29sKTtcbiAgfSxcblxuICBhZGp1c3QoaXRlbXMsIGNvbCkge1xuICAgIHJldHVybiBhZGp1c3QoaXRlbXMsIGNvbCk7XG4gIH0sXG5cbiAgaXRlbShvYmopIHtcbiAgICByZXR1cm4gbWFrZUl0ZW0ob2JqKTtcbiAgfSxcblxuICBmaW5kU3BhY2UoaXRlbSwgaXRlbXMsIGNvbHMpIHtcbiAgICBsZXQgbWF0cml4ID0gbWFrZU1hdHJpeEZyb21JdGVtcyhpdGVtcywgZ2V0Um93c0NvdW50KGl0ZW1zLCBjb2xzKSwgY29scyk7XG5cbiAgICBsZXQgcG9zaXRpb24gPSBmaW5kRnJlZVNwYWNlRm9ySXRlbShtYXRyaXgsIGl0ZW1bY29sc10sIGl0ZW1zKTtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBncmlkSGVscDtcbiIsIjxzY3JpcHQ+XHJcblxyXG5cdGltcG9ydCBJY29uIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbi5zdmVsdGUnO1xyXG5cdGltcG9ydCB7IGdldFBlcnNvbmFsTGV0dGVyIH0gZnJvbSAnLi4vY29udGVudC9wZXJzb25hbExldHRlci5qcyc7XHJcblxyXG5cdGxldCBvcHRpb25zID0gW1xyXG5cdFx0eyB0aXRsZTogJ1BlcnNvbmFsIGxldHRlcicsIGluZm86ICRnZXRQZXJzb25hbExldHRlciB9LFxyXG5cdFx0eyB0aXRsZTogJ0NWJywgaW5mbzogJ3BkZid9LFxyXG5cdFx0eyB0aXRsZTogJ1BvcnRmb2xpbycsIGljb246ICdjb2RlJyB9LFxyXG5cdFx0eyB0aXRsZTogJ1RyYXZlbHMnfSxcclxuXHRcdHsgdGl0bGU6ICdDb250YWN0J30sXHJcblx0XTtcclxuXHJcblx0aW1wb3J0IEdyaWQgZnJvbSBcInN2ZWx0ZS1ncmlkXCI7XHJcblx0aW1wb3J0IGdyaWRIZWxwIGZyb20gXCJzdmVsdGUtZ3JpZC9idWlsZC9oZWxwZXIvaW5kZXgubWpzXCI7XHJcblx0XHJcblx0Y29uc3QgeyBpdGVtIH0gPSBncmlkSGVscDtcclxuXHRjb25zdCBpZCA9ICgpID0+IFwiX1wiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpO1xyXG5cclxuXHRsZXQgaXRlbXMgPSBbXHJcblx0XHQgIHtcclxuXHRcdCAgICBpZDogaWQoKSxcclxuXHRcdCAgICA1OiBpdGVtKHtcclxuXHRcdCAgICAgIHg6IDAsXHJcblx0XHQgICAgICB5OiAwLFxyXG5cdFx0ICAgICAgdzogMixcclxuXHRcdCAgICAgIGg6IDYsXHJcblx0XHQgICAgfSksXHJcblx0XHQgICAgMzogaXRlbSh7IHg6IDAsIHc6IDIsIGg6IDIsIHk6IDAgfSksXHJcblx0XHQgICAgMTogaXRlbSh7IHg6IDAsIHk6IDAsIHc6IDEsIGg6IDIgfSksXHJcblx0XHQgIH0sXHJcblx0XHQgIHtcclxuXHRcdCAgICBpZDogaWQoKSxcclxuXHRcdCAgICA1OiBpdGVtKHtcclxuXHRcdCAgICAgIHg6IDIsXHJcblx0XHQgICAgICB5OiAwLFxyXG5cdFx0ICAgICAgdzogMyxcclxuXHRcdCAgICAgIGg6IDIsXHJcblx0XHQgICAgfSksXHJcblx0XHQgICAgMzogaXRlbSh7IHg6IDIsIHc6IDEsIGg6IDIsIHk6IDAgfSksXHJcblx0XHQgICAgMTogaXRlbSh7IHg6IDAsIHk6IDIsIHc6IDEsIGg6IDIgfSksXHJcblx0XHQgIH0sXHJcblxyXG5cdFx0ICB7XHJcblx0XHQgICAgaWQ6IGlkKCksXHJcblx0XHQgICAgNTogaXRlbSh7XHJcblx0XHQgICAgICB4OiAyLFxyXG5cdFx0ICAgICAgeTogMixcclxuXHRcdCAgICAgIHc6IDMsXHJcblx0XHQgICAgICBoOiAyLFxyXG5cdFx0ICAgIH0pLFxyXG5cdFx0ICAgIDM6IGl0ZW0oeyB4OiAwLCB3OiAzLCBoOiAyLCB5OiAyIH0pLFxyXG5cdFx0ICAgIDE6IGl0ZW0oeyB4OiAwLCB5OiA0LCB3OiAxLCBoOiAyIH0pLFxyXG5cdFx0ICB9LFxyXG5cdFx0XTtcclxuXHJcblx0Y29uc3QgY29scyA9IFtcclxuXHQgIFsxNTAwLCA1XSxcclxuXHQgIFsxMDI0LCAzXSxcclxuXHQgIFs1MDAsIDFdLFxyXG5cdF07XHJcblxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHJcblx0LmNvbnRlbnQgeyBcclxuXHRcdGhlaWdodDogMTAwJTtcclxuXHRcdGJvcmRlci1yYWRpdXM6IDVweDtcclxuXHRcdGJhY2tncm91bmQtY29sb3I6IHdoZWF0O1xyXG5cdFx0Ym94LXNoYWRvdzogMHB4IDFweCA1cHggMHB4IHJnYmEoMCwwLDAsMC4yKTtcclxuXHRcdGN1cnNvcjogZ3JhYjtcclxuXHRcdG92ZXJmbG93OiBoaWRkZW47XHJcblx0fVxyXG5cclxuXHQuY29udGVudCBwIHsgXHJcblx0XHRwYWRkaW5nOiAwcHggMjBweCAwcHggMjBweDtcclxuXHR9XHJcblxyXG5cdC5jb250ZW50IGgzIHtcclxuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcclxuXHR9XHJcblxyXG5cdDpnbG9iYWwoLnN2bHQtZ3JpZC1pdGVtKSB7XHJcblx0XHQvKiBCYWNrIHNoYWRvdyAqL1xyXG5cdFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcclxuXHR9XHJcblx0Omdsb2JhbCguc3ZsdC1ncmlkLXJlc2l6ZXIpIHtcclxuXHRcdG1hcmdpbjogOHB4O1xyXG5cdH1cclxuXHJcblx0LmdyaWQtbWVudS10aXRsZSB7IFxyXG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xyXG5cdH1cclxuXHJcblxyXG48L3N0eWxlPlxyXG5cclxuPGgyIGNsYXNzPVwiZ3JpZC1tZW51LXRpdGxlXCI+XHJcblx0QmUgZmxleGlibGUsIGxpa2UgdGhlc2UgYm94ZXMhIFxyXG48L2gyPlxyXG5cclxuXHJcblxyXG48R3JpZCBiaW5kOml0ZW1zPXtpdGVtc30gcm93SGVpZ2h0PXsxMDB9IGxldDppdGVtIHtjb2xzfSBsZXQ6aW5kZXg+XHJcbiAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cclxuICAgIDxoMz57b3B0aW9uc1tpbmRleF0udGl0bGV9PC9oMz5cclxuICAgIHsjaWYgb3B0aW9uc1tpbmRleF0uaW5mbyAhPT0gJ3BkZid9XHJcbiAgICBcdDxwPntvcHRpb25zW2luZGV4XS5pbmZvfTwvcD5cclxuICAgIHs6ZWxzZX1cclxuICAgIFx0PGEgaHJlZj1cImN2XCIgdGFyZ2V0PVwiX2JsYW5rXCI+IHNlZSA8L2E+XHJcbiAgICB7L2lmfVxyXG4gIDwvZGl2PlxyXG48L0dyaWQ+XHJcbiIsIjxzY3JpcHQ+XHJcblxyXG4gIFx0aW1wb3J0IHsgZmFkZSB9IGZyb20gXCJzdmVsdGUvdHJhbnNpdGlvblwiO1xyXG4gIFx0aW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcclxuXHJcbiAgXHRpbXBvcnQgRmFBcnJvd0FsdENpcmNsZURvd24gZnJvbSAnc3ZlbHRlLWljb25zL2ZhL0ZhQXJyb3dBbHRDaXJjbGVEb3duLnN2ZWx0ZSdcclxuXHRpbXBvcnQgR3JpZE1lbnUgZnJvbSAnLi4vY29tcG9uZW50cy9HcmlkTWVudS5zdmVsdGUnO1xyXG5cclxuXHQvKiBUZXh0IHZhcmlhYmxlcyAqL1xyXG5cdGxldCBpbnRyb1RleHQgPSBbXHJcblx0XHR7IHRleHQ6ICdIaSB0aGVyZSEnLCB3YWl0OiAwfSxcclxuXHRcdHsgdGV4dDogJ0lcXCdtIFdpbGxpYW0gRnJpZWZlbGR0LicsIHdhaXQ6IDEyfSxcclxuXHRcdHsgdGV4dDogJ0FuZCB0aGlzIGlzIG15IHdlYnNpdGUuJywgd2FpdDogMzR9XHJcblx0XTtcclxuXHJcblx0bGV0IHNob3dTdGFydD0gZmFsc2U7XHJcblx0bGV0IGFuaW1hdGlvbkRvbmUgPSBmYWxzZTtcclxuXHJcblx0bGV0IHdhaXRUaW1lID0gMjAwO1xyXG5cclxuICBcdG9uTW91bnQoICgpID0+IHNob3dTdGFydCA9IHRydWUgKTtcclxuXHJcblx0bGV0IHBhZ2VUaXRsZSA9ICdXaWxsaWFtIEZyaWVmZWxkdCc7XHJcblxyXG5cdGxldCBzZWdtZW50ID0gJyc7XHJcblxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxyXG5cdFxyXG5cdEBpbXBvcnQgJy4uLy4uL3N0YXRpYy9fdmFyaWFibGVzLnNjc3MnO1xyXG5cclxuXHQuc3RhcnQtcGFnZS1iYWNrZ3JvdW5kIHtcclxuXHRcdGJhY2tncm91bmQtaW1hZ2U6IHVybChcIi4uL3N0YXJ0LXBhZ2UtYmFja2dyb3VuZC5qcGdcIik7XHJcblx0XHRoZWlnaHQ6IDEwMCU7XHJcblx0XHR3aWR0aDogMTAwJTtcclxuXHRcdC8qIENlbnRlciBhbmQgc2NhbGUgdGhlIGltYWdlIG5pY2VseSAqL1xyXG5cdFx0YmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xyXG5cdFx0YmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcclxuXHRcdGJhY2tncm91bmQtc2l6ZTogY292ZXI7XHRcclxuXHR9XHJcblxyXG5cdC5pbnRyby10ZXh0LWNvbnRhaW5lciB7XHJcblx0XHRwb3NpdGlvbjogc3RpY2t5O1xyXG5cdFx0dG9wOiAxMjVweDtcclxuXHRcdGgxIHtcclxuXHRcdFx0bWFyZ2luLXRvcDogMDtcclxuXHRcdFx0d2lkdGg6IDEwMCU7XHJcblx0XHRcdHRleHQtc2hhZG93OiAycHggMnB4IGJsYWNrO1xyXG5cdFx0XHRjb2xvcjogd2hpdGU7XHJcblx0XHRcdHRleHQtYWxpZ246IGNlbnRlcjtcclxuXHRcdFx0cGFkZGluZy10b3A6IDIwcHg7XHJcblx0XHRcdGZvbnQtd2VpZ2h0OiAzMDA7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQuaWNvbiB7XHJcblx0XHRwb3NpdGlvbjogZml4ZWQ7XHJcblx0XHRib3R0b206IDA7XHJcblx0XHRoZWlnaHQ6IDUwcHg7XHJcblx0XHR3aWR0aDogMTAwdnc7XHJcblx0XHRtYXJnaW4tYm90dG9tOjEwcHg7XHJcbiAgXHR6LWluZGV4OiAxO1xyXG4gIFx0dGV4dC1hbGlnbjogY2VudGVyO1xyXG5cdH1cdFxyXG5cclxuXHQuaWNvbiBhIHtcclxuXHRcdGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xyXG4gICAgcGFkZGluZzogMTVweDtcclxuICAgIGJvcmRlci1yYWRpdXM6IDQwcHg7XHJcbiAgICBib3JkZXI6IDJweCBzb2xpZCBjYWRldGJsdWU7XHJcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcbiAgICBjb2xvcjogY2FkZXRibHVlO1xyXG4gICAgZm9udC1zaXplOiAyMHB4O1xyXG5cdH1cclxuXHJcblx0Lmljb24gYTpob3ZlciB7XHJcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiBjYWRldGJsdWU7XHJcbiAgICBib3JkZXI6IDJweCBzb2xpZCB3aGl0ZTtcclxuICAgIGNvbG9yOiB3aGl0ZTtcclxuXHR9XHJcblxyXG5cdC5pbnRyby1jb250YWluZXIge1xyXG5cdFx0bWFyZ2luLXRvcDogNzBweDtcclxuXHR9XHJcblxyXG48L3N0eWxlPlxyXG5cclxuPHN2ZWx0ZTpoZWFkPlxyXG5cdDx0aXRsZT57cGFnZVRpdGxlfTwvdGl0bGU+XHJcbjwvc3ZlbHRlOmhlYWQ+XHJcblxyXG5cdDxkaXYgc3R5bGU9XCJoZWlnaHQ6MTA1dmhcIj5cclxuXHRcdDxkaXYgY2xhc3M9XCJzdGFydC1wYWdlLWJhY2tncm91bmRcIj5cclxuXHJcblx0XHRcdDxkaXYgY2xhc3M9XCJpbnRyby10ZXh0LWNvbnRhaW5lclwiPlxyXG5cdFx0XHRcdHsjZWFjaCBpbnRyb1RleHQgYXMgaW50cm9MaW5lLCBqfVxyXG5cdFx0XHRcdFx0PGgxPlxyXG5cdFx0XHRcdFx0XHR7I2VhY2ggaW50cm9MaW5lLnRleHQgYXMgY2hhciwgaX1cclxuXHRcdFx0XHRcdFx0XHR7I2lmIHNob3dTdGFydH1cclxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuIHRyYW5zaXRpb246ZmFkZXxsb2NhbD1cInt7IGRlbGF5OiB3YWl0VGltZSArIHdhaXRUaW1lICogaSArIGludHJvTGluZS53YWl0ICogd2FpdFRpbWUgfX1cIlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRvbjppbnRyb2VuZD1cInsoKSA9PiB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoaSA9PT0gMjIpIGFuaW1hdGlvbkRvbmUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR9fVwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHtjaGFyWzBdfVxyXG5cdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxyXG5cdFx0XHRcdFx0XHRcdHsvaWZ9XHJcblx0XHRcdFx0XHRcdHsvZWFjaH1cclxuXHRcdFx0XHRcdDwvaDE+XHJcblx0XHRcdFx0ey9lYWNofVx0XHRcclxuXHRcdFx0PC9kaXY+XHJcblxyXG5cdFx0PC9kaXY+XHRcclxuXHQ8L2Rpdj5cclxuXHJcblx0eyNpZiBhbmltYXRpb25Eb25lfVxyXG5cdFx0PGRpdiBjbGFzcz1cImljb25cIj5cclxuXHRcdFx0PGEgaHJlZj1cIi9pbnRyb1wiPlxyXG5cdFx0XHRcdFdobyBhbSBJP1xyXG5cdFx0XHQ8L2E+XHJcblx0XHQ8L2Rpdj5cclxuXHR7L2lmfVxyXG5cdCJdLCJuYW1lcyI6WyJnZXRSb3dzQ291bnQiLCJtYWtlTWF0cml4IiwiZmluZENsb3NlQmxvY2tzIiwibWFrZU1hdHJpeEZyb21JdGVtc0lnbm9yZSIsImZpbmRJdGVtc0J5SWQiLCJmaW5kRnJlZVNwYWNlRm9ySXRlbSIsImdldEl0ZW0iLCJ1cGRhdGVJdGVtIiwibW92ZUl0ZW0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVBRzRDLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lHQUFQLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQ2M5QyxHQUFRLFFBQUssTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQW5CLEdBQVEsUUFBSyxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWZaLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7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LEdBQ0wsQ0FBQyxFQUFFLENBQUMsRUFDSixDQUFDLEVBQUUsQ0FBQyxFQUNKLENBQUMsRUFBRSxDQUFDLEVBQ0osQ0FBQyxFQUFFLENBQUM7R0FFTixDQUFDLEVBQUUsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0dBQ2hDLENBQUMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7OztHQUdoQyxFQUFFLEVBQUUsRUFBRTtHQUNOLENBQUMsRUFBRSxJQUFJLEdBQ0wsQ0FBQyxFQUFFLENBQUMsRUFDSixDQUFDLEVBQUUsQ0FBQyxFQUNKLENBQUMsRUFBRSxDQUFDLEVBQ0osQ0FBQyxFQUFFLENBQUM7R0FFTixDQUFDLEVBQUUsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0dBQ2hDLENBQUMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7OztHQUloQyxFQUFFLEVBQUUsRUFBRTtHQUNOLENBQUMsRUFBRSxJQUFJLEdBQ0wsQ0FBQyxFQUFFLENBQUMsRUFDSixDQUFDLEVBQUUsQ0FBQyxFQUNKLENBQUMsRUFBRSxDQUFDLEVBQ0osQ0FBQyxFQUFFLENBQUM7R0FFTixDQUFDLEVBQUUsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0dBQ2hDLENBQUMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Ozs7T0FJL0IsSUFBSSxLQUNQLElBQUksRUFBRSxDQUFDLElBQ1AsSUFBSSxFQUFFLENBQUMsSUFDUCxHQUFHLEVBQUUsQ0FBQzs7Ozs7Ozs7RUE0Q1EsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQ1BaLEdBQUksS0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BSnVCLEtBQUssZUFBRSxHQUFRLG1CQUFHLEdBQVEsWUFBRyxHQUFDLHFCQUFHLEdBQVMsSUFBQyxJQUFJLGdCQUFHLEdBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7O01BQTFELEtBQUssZUFBRSxHQUFRLG1CQUFHLEdBQVEsWUFBRyxHQUFDLHFCQUFHLEdBQVMsSUFBQyxJQUFJLGdCQUFHLEdBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQUR0RixHQUFTOzs7Ozs7Ozs7Ozs7Ozs7O3FCQUFULEdBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQURSLEdBQVMsSUFBQyxJQUFJOzs7O2tDQUFuQixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUNBQUMsR0FBUyxJQUFDLElBQUk7Ozs7aUNBQW5CLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7c0NBQUosTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Q0FUSCxHQUFTO2dDQU9QLEdBQVM7Ozs7Z0NBQWQsTUFBSTs7OztrQ0FtQkosR0FBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnRkExQlYsR0FBUzs7Ozs7K0JBT1AsR0FBUzs7OzsrQkFBZCxNQUFJOzs7Ozs7Ozs7Ozs7Ozs7O29DQUFKLE1BQUk7Ozt5QkFtQkosR0FBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FsR2QsU0FBUztJQUNWLElBQUksRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDMUIsSUFBSSxFQUFFLHdCQUF5QixFQUFFLElBQUksRUFBRSxFQUFFOztHQUN6QyxJQUFJLEVBQUUseUJBQXlCO0dBQUUsSUFBSSxFQUFFLEVBQUU7Ozs7S0FHeEMsU0FBUyxHQUFFLEtBQUs7S0FDaEIsYUFBYSxHQUFHLEtBQUs7S0FFckIsUUFBUSxHQUFHLEdBQUc7Q0FFaEIsT0FBTyx1QkFBUSxTQUFTLEdBQUcsSUFBSTtLQUU3QixTQUFTLEdBQUcsbUJBQW1CO0tBRS9CLE9BQU8sR0FBRyxFQUFFOzs7Ozs7OztNQXNFSixDQUFDLEtBQUssRUFBRSxrQkFBRSxhQUFhLEdBQUcsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9
